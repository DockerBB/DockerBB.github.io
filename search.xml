<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>混合背包</title>
    <url>/posts/4687017g.html</url>
    <content><![CDATA[<blockquote>
<p>有 N 种物品和一个容量是 V 的背包。<br>物品一共有三类：</p>
</blockquote>
<ol>
<li>第一类物品只能用1次（01背包）；</li>
<li>第二类物品可以用无限次（完全背包）；</li>
<li>第三类物品最多只能用 $s_i$ 次（多重背包）；<br>每种体积是 $v_i$，价值是 $w_i$。</li>
</ol>
<ul>
<li>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。<a id="more"></a>
思路:<blockquote>
<blockquote>
<p>按类别处理就行，要注意的就是将多重背包转化为二进制优化的01背包就行。</p>
</blockquote>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goods</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> type,v,w;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Goods&gt;goods;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">                goods.push_back(&#123;<span class="number">-1</span>,k*v,k*w&#125;);</span><br><span class="line">                s-=k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;<span class="number">0</span>)goods.push_back(&#123;<span class="number">-1</span>,s*v,s*w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> goods.push_back(&#123;s,v,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g:goods)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!g.type)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=g.v;j&lt;=m;j++)f[j] = <span class="built_in">max</span>(f[j],f[j-g.v]+g.w);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=g.v;j--)f[j] = <span class="built_in">max</span>(f[j],f[j-g.v]+g.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LLeetcode动态规划专题</title>
    <url>/posts/59a5b963.html</url>
    <content><![CDATA[<blockquote>
<p>感觉dp真的很困难，刷不动。打算后面几天刷一下dp的题。</p>
</blockquote>
<a id="more"></a>

<h1 id="leetcode-5-最长回文子串："><a href="#leetcode-5-最长回文子串：" class="headerlink" title="leetcode 5 最长回文子串："></a>leetcode 5 最长回文子串：</h1><blockquote>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入: “babad”</span><br><span class="line">输出: “bab”</span><br><span class="line">注意: “aba” 也是一个有效答案。</span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入: “cbbd”</span><br><span class="line">输出: “bb”</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a></li>
</ul>
<blockquote>
<p>思路：参考了算法笔记的最长回文子串的做法，时间复杂度为\(O(N^2)\)。令dp[i][j]表示s[i]到s[j]所表示的子串是否时回文子串，是则为1，不是为0。这样根据s[i]是否等于s[j]，就可以把转移情况分为两类：<br>s[i]==s[[j],那么只要s[i+1][j-1]是回文子串，s[i]至s[j]就是回文子串；如果s[i+1][j-1]不是回文子串，则s[i]至s[j]也不是回文子串。<br>s[i]!=s[j]，那么s[i]至s[j]一定不是回文子串。<br>由此可以写出状态转移方程：<br>\(<br>dp[i][j] =<br>\begin{cases}<br>dp[i+1][j-1],  &amp; \text{s[i]==s[j]} \\<br>0,  &amp; \text{s[i]!=s[j]}<br>\end{cases}<br>\)<br>边界：\(dp[i][i]=1,dp[i][i+1]=(s[i]==s[i+1])?1:0\)。<br>到这里还有一个问题没有解决，那就是如果按照i和j从小到大的顺序来枚举子串的两个端点，然后更新dp[i][j],会无法保证dp[i+1][j-1]已经被计算过，从而无法得到正确的dp[i][j]。<br>如图所示，先固定i==0，然后枚举j从2开始。当求解dp[0][2]时，将会转换为求dp[1][1],而dp[1][1]时在初试化中得来得，当求解dp[0][3]时，将会转换为dp[1][2],而dp[1][2]也是在初始化中得来的，当求解dp[0][4]时，将会转换为dp[1][3],但是dp[1][3]并不是已经计算过的值，因此无法状态转移。事实上，无论对i和j的枚举顺序作何调整，都无法调和这个矛盾，因此必须想办法寻找新的枚举方式。<br>根据递推写法从边界出发的原理，注意到边界表示的是长度为1和2的子串，且每次转移时都对子串的长度减了1，因此不妨考虑按子串的初始位置进行枚举，即第一遍将长度为3的子串的dp值全部求出，第二遍通过第一遍结果计算出长度为4的子串的dp值…这样就可以避免状态无法转移的问题。可以先枚举子串长度L,再枚举左端点i，这样右端点i+L-1也可以直接得到。<br><img src="https://ae01.alicdn.com/kf/H667ca6c331af4b918ead3509366b5def3.png" alt=""></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(),ans=<span class="number">1</span>,temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    ans = <span class="number">2</span>;</span><br><span class="line">                    temp = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">3</span>;L&lt;=n;L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+L<span class="number">-1</span>&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+L<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    temp = i;</span><br><span class="line">                    ans = L;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = temp + ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=temp;i&lt;m;i++)res+=s[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode-647-回文子串"><a href="#leetcode-647-回文子串" class="headerlink" title="leetcode 647 回文子串"></a>leetcode 647 回文子串</h1><blockquote>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。<br>示例 1:<br>输入: “abc”<br>输出: 3<br>解释: 三个回文子串: “a”, “b”, “c”.<br>示例 2:<br>输入: “aaa”<br>输出: 6<br>说明: 6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>注意:<br>输入的字符串长度不会超过1000。</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/palindromic-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindromic-substrings</a></li>
</ul>
<blockquote>
<p>思路：上面的代码稍加修改即可解。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(),result=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">3</span>;L&lt;=n;L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+L<span class="number">-1</span>&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i+L<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="leetcod-1025-除数博弈"><a href="#leetcod-1025-除数博弈" class="headerlink" title="leetcod 1025 除数博弈"></a>leetcod 1025 除数博弈</h1><blockquote>
<p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字N 。在每个玩家的回合，玩家需要执行以下操作：<br>选出任一x，满足 0 &lt; x &lt; N 且 N % x == 0 。<br>用 N - x 替换黑板上的数字 N 。<br>如果玩家无法执行这些操作，就会输掉游戏。<br>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。<br>示例 1：<br>输入：2<br>输出：true<br>解释：爱丽丝选择 1，鲍勃无法进行操作。<br>示例 2：<br>输入：3<br>输出：false<br>解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。<br>提示：<br>1 &lt;= N &lt;= 1000</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/divisor-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/divisor-game</a></li>
</ul>
<blockquote>
<p>思路：有一种取巧找规律的做法很简单就不说了，自己推一下就行了。说一下自己的动态规划做法。首先明确一点，就是对于每个数其胜负结果都是确定的，也就是说每一个必胜态都有一个必败态的转化，每个必败态都有一个必胜态的转化。举个栗子：用dp数组来记录每个N的胜负情况，显然dp[1]=0,dp[2]=1,dp[3]=0,我们可以有前面状态的dp[i]来递推出后面dp[i+1]。求解dp[4]时，我们判断从dp[1-3]中可以被4整除数中是否有一个使得N-x必败态的数，如果有，则dp[4]则为必胜态，因为先手选数的玩家选了那个数后，使得对面到了必败态。例如我们可以选的数有1，2,选后的状态为dp[3]=0，dp[2]=1,所以我们肯定要选1使得对方转到必败态。代码实现也很简单：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> dp[<span class="number">1010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">0</span>,dp[<span class="number">2</span>]=<span class="number">1</span>,dp[<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;N<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i-j]==<span class="number">0</span>)dp[i]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="leetcode-303-区域和检索"><a href="#leetcode-303-区域和检索" class="headerlink" title="leetcode 303 区域和检索"></a>leetcode 303 区域和检索</h1><blockquote>
<p>给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。<br>示例：<br>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()<br>sumRange(0, 2) -&gt; 1<br>sumRange(2, 5) -&gt; -1<br>sumRange(0, 5) -&gt; -3<br>说明:<br>你可以假设数组不可变。<br>会多次调用 sumRange 方法。</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/range-sum-query-immutable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/range-sum-query-immutable</a></li>
</ul>
<blockquote>
<p>思路：水题，直接前缀和完事。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp,num;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        num = nums;</span><br><span class="line">        presum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j]-dp[i]+num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">presum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            dp.push_back(num[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp.push_back(dp[i<span class="number">-1</span>]+num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp,num;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nums.<span class="built_in">size</span>();</span><br><span class="line">        num = nums;</span><br><span class="line">        presum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j]-dp[i]+num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">presum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            dp.push_back(num[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp.push_back(dp[i<span class="number">-1</span>]+num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 377 组合总和Ⅳ</title>
    <url>/posts/758b2bfb.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">target = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line"></span><br><span class="line">因此输出为 <span class="number">7</span>。</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iv</a></li>
</ul>
<blockquote>
<p>思路：第一想法就是暴搜,从数组的第一个数开始，搜索使用第一个数字，看能有多少种方案可以使总和恰好为target，然后继续算用以第二个数字作为第一数字能有多少种方案可以使综合恰好为target,以此类推。这种方法的弊端非常明显，如果target比数组的数都大很多的话，递归深度太深了会超时，所以果然TEL了。后面想到可以做记忆化，用ans记录总和恰好等于target的所有方案数，所以有<br>\(ans[target]=ans[target-current] + count\)状态转移方程。其中current表示1target之中的状态，count表示总和恰好为current时有多少种方案。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">超时代码:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        dfs(target,target,candidates);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span> remain,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dfs(target,remain - candidates[i],candidates);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">加了记忆化之后的代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; temp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        temp = <span class="built_in">vector</span>(target+<span class="number">1</span>,<span class="number">-1l</span>l);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            dfs(i,i,candidates);</span><br><span class="line">            temp[i]=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span> remain,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp[remain]!=<span class="number">-1</span>)&#123;<span class="comment">//如果还要凑的数已经算过了则加上当前方案数之和返回即可。</span></span><br><span class="line">            count+=temp[remain];</span><br><span class="line">            count%=INT_MAX;<span class="comment">//防止超出整数的表示范围</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dfs(target,remain - candidates[i],candidates);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 72 编辑距离</title>
    <url>/posts/5a2e5835.html</url>
    <content><![CDATA[<blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">horse -&gt; rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">'e'</span>)</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: word1 = <span class="string">"intention"</span>, word2 = <span class="string">"execution"</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释:</span><br><span class="line">intention -&gt; inention (删除 <span class="string">'t'</span>)</span><br><span class="line">inention -&gt; enention (将 <span class="string">'i'</span> 替换为 <span class="string">'e'</span>)</span><br><span class="line">enention -&gt; exention (将 <span class="string">'n'</span> 替换为 <span class="string">'x'</span>)</span><br><span class="line">exention -&gt; exection (将 <span class="string">'n'</span> 替换为 <span class="string">'c'</span>)</span><br><span class="line">exection -&gt; execution (插入 <span class="string">'u'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance</a></li>
</ul>
<blockquote>
<p>思路：f[i,j]表示将word1前i个字母变为word2前j个字母需要的最少操作数。所以可以分成三类：插入，删除，替换<br>状态转移如图所示<br><img src="https://ae01.alicdn.com/kf/H56b598d3701948c081878842e04a0525R.png" alt=""></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = word1.<span class="built_in">size</span>(),m = word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)f[i][<span class="number">0</span>]=i;<span class="comment">//初始化 将word1前i个字母变成word2前0个字母需要将前i个字母删掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)f[<span class="number">0</span>][i]=i;<span class="comment">//初始化 将word1前0个字母变成word2前i个字母需要将前i个字母插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>] + (word1[i<span class="number">-1</span>]!=word2[j<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 52 N皇后题解</title>
    <url>/posts/d11b2892.html</url>
    <content><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<a id="more"></a>

<p><img src="https://ae01.alicdn.com/kf/Ha9739138b02145c289d0c1b9bca533faH.png" alt=""></p>
<blockquote>
<p>上图为 8 皇后问题的一种解法。<br>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>示例:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: [</span><br><span class="line"> [<span class="string">".Q.."</span>,  <span class="comment">// 解法 1</span></span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"..Q."</span>],</span><br><span class="line"></span><br><span class="line"> [<span class="string">"..Q."</span>,  <span class="comment">// 解法 2</span></span><br><span class="line">  <span class="string">"Q..."</span>,</span><br><span class="line">  <span class="string">"...Q"</span>,</span><br><span class="line">  <span class="string">".Q.."</span>]</span><br><span class="line">]</span><br><span class="line">解释: <span class="number">4</span> 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a></li>
</ul>
<blockquote>
<p>思路：首先考虑暴力求解，从\(n^2\)个位置中选择n个位置，那么将需要枚举\(C_{n*n}^n\)次,当n=8时就是54502232次枚举，如果n更大，那么就炸了。所以要换个思路，考虑每行只能放一个皇后，每列只能放一个皇后，如果把n列皇后所在的行号依次写出，那么就是1-n的一个排列。于是只需要枚举1-n的所有排列，查看每个排列对应得放置方案是否合法，当n=8时，只需要40320次枚举。遍历每两个皇后，判断他们是否在一条对角线上(不在同一行和同一列是显然得)，若不是则为一种情况,加入ans中。实现如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> P[<span class="number">10</span>],hashTable[<span class="number">10</span>]=&#123;<span class="literal">false</span>&#125;,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=m;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(P[i]-P[j]))&#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;t;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="built_in">string</span> r = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)r+=<span class="string">"."</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)t.push_back(r);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)t[P[i]<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">'Q'</span>;</span><br><span class="line">                ans.push_back(t);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m;x++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">                P[index]=x;</span><br><span class="line">                hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">                generateP(index+<span class="number">1</span>);</span><br><span class="line">                hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        m=n;</span><br><span class="line">        generateP(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上，通过思考可以发现，当已经放置了一部分皇后之后，可能剩余得皇后无论怎样都不可能合法，此时就没必要往下递归了，直接返回上层即可，这样可以减少很多计算量，例如35141，当放置了前3个皇后，可以发现剩下两个皇后无论怎么放都会产生冲突，就没必要继续递归了。<br>回溯算法如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> P[<span class="number">10</span>],hashTable[<span class="number">10</span>]=&#123;<span class="literal">false</span>&#125;,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(index == m+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> r;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)r+=<span class="string">"."</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)t.push_back(r);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)t[P[i]<span class="number">-1</span>][i<span class="number">-1</span>]=<span class="string">'Q'</span>;</span><br><span class="line">            ans.push_back(t);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m;x++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> pre =<span class="number">1</span>;pre&lt;index;pre++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(index-pre)==<span class="built_in">abs</span>(x-P[pre]))&#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    P[index]=x;</span><br><span class="line">                    hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">                    generateP(index+<span class="number">1</span>);</span><br><span class="line">                    hashTable[x]=<span class="literal">false</span>;  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        m=n;</span><br><span class="line">        generateP(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>dfs</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dfs</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习记录面向对象编程-动态属性-原型-静态方法-继承-map-WeakMap-异常</title>
    <url>/posts/279f5654.html</url>
    <content><![CDATA[<blockquote>
<p>Js面向对象编程</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">面向对象编程</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">const</span> car2 = <span class="keyword">new</span> Car();</span><br><span class="line">console.<span class="built_in">log</span>(car1 instanceof Car);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor(make,model)&#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.userGears = [<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'R'</span>,<span class="string">'D'</span>];</span><br><span class="line">        <span class="keyword">this</span>.userGear = <span class="keyword">this</span>.userGears[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    shift(gear)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.userGears.indexOf(gear)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear: $&#123;gear&#125;`);</span><br><span class="line">        <span class="keyword">this</span>.userGear = gear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">"Tesla"</span>,<span class="string">"Model S"</span>);</span><br><span class="line">car1.shift(<span class="string">'D'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car1.make,car1.model,car1.userGear);</span><br><span class="line">动态属性</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor(make,model)&#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>._userGears = [<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'R'</span>,<span class="string">'D'</span>];<span class="comment">//穷人访问限制 给私有属性加下划线前缀</span></span><br><span class="line">        <span class="keyword">this</span>._userGear = <span class="keyword">this</span>._userGears[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">get</span> <span class="title">userGear</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._userGear; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">set</span> <span class="title">userGear</span><span class="params">(value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._userGears.indexOf(value)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear: $&#123;value&#125;`);</span><br><span class="line">        <span class="keyword">this</span>._userGear = value;</span><br><span class="line">    &#125;</span><br><span class="line">    shift(gear)&#123;<span class="keyword">this</span>.userGear = gear;&#125;</span><br><span class="line">&#125;<span class="comment">/*并没有解决直接赋值问题*/</span></span><br><span class="line"><span class="comment">// WeakMap强制属性私有化</span></span><br><span class="line"><span class="keyword">const</span> Car = (function () &#123;</span><br><span class="line">    <span class="keyword">const</span> carProps = <span class="keyword">new</span> WeakMap();</span><br><span class="line"></span><br><span class="line">    class Car &#123;</span><br><span class="line">        constructor(make, model) &#123;</span><br><span class="line">            <span class="keyword">this</span>.make = make;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">            <span class="keyword">this</span>._userGears = [<span class="string">'P'</span>, <span class="string">'N'</span>, <span class="string">'R'</span>, <span class="string">'D'</span>];</span><br><span class="line">            carProps.<span class="built_in">set</span>(<span class="keyword">this</span>, &#123;userGear: <span class="keyword">this</span>._userGears[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">get</span> userGear() &#123;</span><br><span class="line">            <span class="keyword">return</span> carProps.<span class="built_in">get</span>(<span class="keyword">this</span>).userGear;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">set</span> userGear(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._userGears.indexOf(value) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear:$&#123;value&#125;`);</span><br><span class="line">            carProps.<span class="built_in">get</span>(<span class="keyword">this</span>).userGear = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shift(gear) &#123;</span><br><span class="line">            <span class="keyword">this</span>.userGear = gear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Car;</span><br><span class="line">&#125;)();<span class="comment">/*这里使用即时调用函数将WeakMap隐藏再一个闭包内，从而阻止了外界的访问。这个WeakMap可以安全的存储任何不</span></span><br><span class="line"><span class="comment">像被Car类外部访问的属性*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">const</span> car2 = <span class="keyword">new</span> Car();</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === Car.prototype.shift);</span><br><span class="line">car1.shift(<span class="string">"D"</span>);</span><br><span class="line"><span class="comment">//car1.shift('d')报错</span></span><br><span class="line">console.<span class="built_in">log</span>(car1.userGear);</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === car2.shift);</span><br><span class="line"></span><br><span class="line">car1.shift = function (gear) &#123;</span><br><span class="line">    <span class="keyword">this</span>.userGear = gear.toUpperCase();</span><br><span class="line">&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === Car.prototype.shift);</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === car2.shift);</span><br><span class="line">car1.shift(<span class="string">'d'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car1.userGear);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*到目前为止，讨论的方法都是实例方法。它们只针对每个具体的实例才有用。还有一种静态方法，它不与实例绑定。在静态</span></span><br><span class="line"><span class="comment">方法中，this绑定的是类本身，但通常使用类名来代替this是公认的最佳实践。静态方法通常用来执行与类相关的任务，而非</span></span><br><span class="line"><span class="comment">跟具体的实例相关。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car1</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">getNextVin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Car1.nextVin++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(make, model) &#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.vin = Car1.getNextVin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">areSimilar</span><span class="params">(car1, car2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car1.make === car2.make &amp;&amp; car1.model === car2.model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">areSame</span><span class="params">(car1, car2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car1.vin === car2.vin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car1.nextVin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car3 = <span class="keyword">new</span> Car1(<span class="string">"Tesla"</span>, <span class="string">"S"</span>);</span><br><span class="line"><span class="keyword">const</span> car4 = <span class="keyword">new</span> Car1(<span class="string">"Mazda"</span>, <span class="string">"3"</span>);</span><br><span class="line"><span class="keyword">const</span> car5 = <span class="keyword">new</span> Car1(<span class="string">"Mazda"</span>, <span class="string">"3"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car3.vin);</span><br><span class="line">console.<span class="built_in">log</span>(car4.vin);</span><br><span class="line">console.<span class="built_in">log</span>(car5.vin);</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSimilar(car3, car4));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSimilar(car4, car5));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSame(car4, car5));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSame(car4, car4));</span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="comment">/*在分析原型的时候，已经看到了继承的身影：当创建一个类的实例时，它继承了类原型中的所有的功能。如果一个方法没</span></span><br><span class="line"><span class="comment">有在对象原型中找到其定义，它会检查原型的原型。这样就建立了一个原型链。JavaScript会沿着原型链走下去，直到某个</span></span><br><span class="line"><span class="comment">原型满足了需求。如果找不到这样的原型，程序最终会报错。原型链的最大好处就是能够建立类的层次结构。前面已经讨论</span></span><br><span class="line"><span class="comment">了汽车如何归属与一种交通工具。原型链允许将功能置于最合适的继承层次上。例如，汽车可能有个方法deployAirbags，</span></span><br><span class="line"><span class="comment">可以将它当作一般的交通工具方法，但是，大家做过配备安全气囊的船吗？另一方面，几乎左右的交通工具都可以搭载乘客，</span></span><br><span class="line"><span class="comment">所以交通工具都可能有addPassenger的方法。下面实现这种场景*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.passengers = [];</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"Vehicle created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addPassenger(p) &#123;</span><br><span class="line">        <span class="keyword">this</span>.passengers.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car2</span> <span class="title">extends</span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();<span class="comment">//特殊函数 调用了父类的构造器，必须调用否则报错</span></span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"Car created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deployAirbags() &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"BWOOSH"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vehicle.prototype.sneaky = <span class="string">"not recommended!"</span>;</span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v.addPassenger(<span class="string">"Frank"</span>);</span><br><span class="line">v.addPassenger(<span class="string">"Judy"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(v.passengers);</span><br><span class="line"><span class="keyword">const</span> c  = <span class="keyword">new</span> Car2();</span><br><span class="line">c.addPassenger(<span class="string">"Alice"</span>);</span><br><span class="line">c.addPassenger(<span class="string">"Cameron"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(let p in c)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;p&#125;: $&#123;c[p]&#125;`+</span><br><span class="line">        (c.hasOwnProperty(p) ? '' : '(inherited)'));</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(c.passengers);</span><br><span class="line"><span class="comment">//v.deployAirbags()报错</span></span><br><span class="line">c.deployAirbags();<span class="comment">/*注意到可以在c上调用deployAirbags,但是不能在v上调用。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">const u1 = &#123;name:'Cynthia'&#125;;</span><br><span class="line">const u2 = &#123;name:'Jackson'&#125;;</span><br><span class="line">const u3 = &#123;name:'James'&#125;;</span><br><span class="line"><span class="comment">// const userRoles = new Map();</span></span><br><span class="line"><span class="comment">// userRoles.set(u1,"User");</span></span><br><span class="line"><span class="comment">// userRoles.set(u2,"User");</span></span><br><span class="line"><span class="comment">// userRoles.set(u3,"Admin");</span></span><br><span class="line"><span class="comment">//set()链式赋值</span></span><br><span class="line"><span class="comment">//const userRoles = new Map();</span></span><br><span class="line"><span class="comment">// userRoles</span></span><br><span class="line"><span class="comment">//     .set(u1,"User")</span></span><br><span class="line"><span class="comment">//     .set(u2,"User")</span></span><br><span class="line"><span class="comment">//     .set(u3,"Admin");</span></span><br><span class="line"><span class="comment">//map的构函数赋值</span></span><br><span class="line"><span class="keyword">const</span> userRoles = <span class="keyword">new</span> Map([</span><br><span class="line">    [u1,'User'],</span><br><span class="line">    [u2,'User'],</span><br><span class="line">    [u3,'Admin']</span><br><span class="line">]);</span><br><span class="line"><span class="comment">/*如果key已经在map种，调用set()后key对应的value就会被替换</span></span><br><span class="line"><span class="comment">* size属性返回map的元素个数</span></span><br><span class="line"><span class="comment">* keys()方法可以拿到map中的所有键，values()可以拿到所有的值</span></span><br><span class="line"><span class="comment">* entries()可以以数组的方式获取键值对，数组的第一个元素为键，第二个为值。所有的这些方法返回一个可</span></span><br><span class="line"><span class="comment">* 以迭代的对象从而可以用for...of循环迭代*/</span></span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.keys())console.<span class="built_in">log</span>(u.name);</span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.values())console.<span class="built_in">log</span>(u);;</span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.entries())console.<span class="built_in">log</span>(`$&#123;u[<span class="number">0</span>].name&#125;: $&#123;u[<span class="number">1</span>]&#125;`);</span><br><span class="line"><span class="comment">//通过解构让迭代更自然</span></span><br><span class="line"><span class="keyword">for</span>(let [u,r] of userRoles.entries())console.<span class="built_in">log</span>(`$&#123;u.name&#125;: $&#123;r&#125;`);</span><br><span class="line"><span class="comment">//如果需要一个数组，可以用展开运算符：</span></span><br><span class="line">console.<span class="built_in">log</span>([...userRoles.values()]);</span><br><span class="line"><span class="comment">//使用delete()方法可以删除map中的一个条目</span></span><br><span class="line">userRoles.<span class="keyword">delete</span>(u2);</span><br><span class="line">console.<span class="built_in">log</span>(userRoles.<span class="built_in">size</span>)</span><br><span class="line"><span class="comment">//如果想删除所有调用clear()方法</span></span><br><span class="line">userRoles.<span class="built_in">clear</span>();</span><br><span class="line">console.<span class="built_in">log</span>(userRoles.<span class="built_in">size</span>);</span><br><span class="line"><span class="comment">//Weak maps</span></span><br><span class="line"><span class="comment">/*本质和Map相同除了以下几点</span></span><br><span class="line"><span class="comment">* key必须时对象</span></span><br><span class="line"><span class="comment">* WeakMap中的key可以被垃圾回收</span></span><br><span class="line"><span class="comment">* WeakMap不能被迭代或者清空*/</span></span><br><span class="line"><span class="keyword">const</span> SecretHolder = (function () &#123;</span><br><span class="line">    <span class="keyword">const</span> secrets = <span class="keyword">new</span> WeakMap();</span><br><span class="line">    <span class="keyword">return</span> class &#123;</span><br><span class="line">        setSecret(secret)&#123;</span><br><span class="line">            secrets.<span class="built_in">set</span>(<span class="keyword">this</span>,secret);</span><br><span class="line">        &#125;</span><br><span class="line">        getSecret()&#123;</span><br><span class="line">            <span class="keyword">return</span> secrets.<span class="built_in">get</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">/*这里把WeakMap放在IIFE中，同时还放入了一个使用它的类。在IIFE外，有一个叫做SectetHolder的类，这个类的实例可</span></span><br><span class="line"><span class="comment">以存储secrets.secret的赋值和取值只能分别通过setSecret方法和getSecret方法完成*/</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> SecretHolder();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> SecretHolder();</span><br><span class="line">a.setSecret(<span class="string">"secret A"</span>);</span><br><span class="line">b.setSecret(<span class="string">"secret B"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(a.getSecret() + b.getSecret());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Error对象</span></span><br><span class="line"><span class="function">function <span class="title">validateEmail</span><span class="params">(email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> email.match(/@/)?</span><br><span class="line">        email:</span><br><span class="line">        <span class="keyword">new</span> Error(`invalid email: $&#123;email&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> email = <span class="string">"jane@doe.com"</span>;</span><br><span class="line"><span class="keyword">const</span> validatedEmail = validateEmail(email);</span><br><span class="line"><span class="keyword">if</span>(validatedEmail instanceof Error)&#123;</span><br><span class="line">    console.error(`Error: $&#123;validatedEmail.message&#125;`);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`Valid email: $&#123;validatedEmail&#125;`);</span><br><span class="line">&#125;<span class="comment">/*可以通过typeof运算符判断返回的是不是Error实例然后通过Error的message属性来获取错误信</span></span><br><span class="line"><span class="comment">息。虽然这样使用Error实例完全合法，也很有用，但实际上，它的大部分应用场景都在异常处理</span></span><br><span class="line"><span class="comment">中，这也是接下来要学的内容*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用try...catch处理异常</span></span><br><span class="line"><span class="comment">/*如果将前面的例子中的email设为null、数字、对象等任何非字符串值时都会出错，此时程序将</span></span><br><span class="line"><span class="comment">* 会非常不友好的崩溃。为了防范这种非预期错误，可以将用于验证邮箱的代码封装在try..catch</span></span><br><span class="line"><span class="comment">* 语句中*/</span></span><br><span class="line"><span class="keyword">const</span> email_ = null;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> validatedEmail = validateEmail(email_);</span><br><span class="line">    <span class="keyword">if</span>(validatedEmail instanceof Error)&#123;</span><br><span class="line">        console.error(`Error: $&#123;validatedEmail.message&#125;`);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(`Valid email: $&#123;validatedEmail&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`Error: $&#123;e.message&#125;`);</span><br><span class="line">&#125;<span class="comment">/*捕获异常后，程序就不会再崩溃了，而是打印了错误日志后继续执行。不过可能还会有别的问题：</span></span><br><span class="line"><span class="comment">如果这里需要输入一个合法的邮箱，而用户输入了无效的邮箱，那程序继续运行下去也没有意义了。</span></span><br><span class="line"><span class="comment">注意，一旦有错误产生，执行逻辑立即跳到catch中。所以validateEmail调用语句后的if语句就不</span></span><br><span class="line"><span class="comment">会执行。也可以再try块中写入任何期望的语句，最先产生错误的语句会使执行逻辑跳转到catch块</span></span><br><span class="line"><span class="comment">中。如果try块中的语句没有任何错误，catch块中的代码就不会被执行，程序会继续运行下去。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="comment">/*function  billPay(amount,payee,account) &#123;</span></span><br><span class="line"><span class="comment">    if(amount &gt; account.balance)</span></span><br><span class="line"><span class="comment">        throw new Error("insufficient funds");</span></span><br><span class="line"><span class="comment">    account.transfer(payee,amount);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常处理和调用栈</span></span><br><span class="line"><span class="function">function <span class="title">a_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log('a: calling b');</span><br><span class="line">    b_();</span><br><span class="line">    console.log('a: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">b_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"b: calling c"</span>);</span><br><span class="line">    c_();</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"b: done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">c_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"c: throwing error"</span>);</span><br><span class="line">    throw new Error('c error');</span><br><span class="line">    console.log('c: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">d_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log('d: calling c');</span><br><span class="line">    c_();</span><br><span class="line">    console.log('d: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a_();</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e.<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    d_();</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e.<span class="built_in">stack</span>);</span><br><span class="line">&#125;<span class="comment">/*栈轨迹从最深层的函数开始，直到没有函数调用。所以出现异常应该从最上面开始解决*/</span></span><br><span class="line"><span class="comment">//try...catch...finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"this line is executed..."</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"whoops"</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"whis line is not..."</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"there was an error.."</span>);</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"...always executed"</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"perform cleanup here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript迭代器和函数深入</title>
    <url>/posts/ba033a64.html</url>
    <content><![CDATA[<blockquote>
<p>Js迭代器和函数深入</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器和生成器</span></span><br><span class="line"><span class="keyword">const</span> book = [</span><br><span class="line">    <span class="string">"Twinkle, twinkle, little bat!"</span>,</span><br><span class="line">    <span class="string">"How I wonder what you're at!"</span>,</span><br><span class="line">    <span class="string">"Up above the world you fly,"</span>,</span><br><span class="line">    <span class="string">"Like a tea tray in the sky."</span>,</span><br><span class="line">    <span class="string">"Twinkle, twinkle, little bat!"</span>,</span><br><span class="line">    <span class="string">"How I wonder what you're at!"</span></span><br><span class="line">];</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">const</span> it = book.values();<span class="comment">//values（）方法获取迭代器</span></span><br><span class="line"><span class="keyword">for</span> (let i = it.next(); !i.done; i = it.next()) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(i.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代协议</span></span><br><span class="line"><span class="comment">/*迭代器协议可以让任何对象变得可迭代</span></span><br><span class="line"><span class="comment">* 如果一个类提供了一个符号方法Symbol.iterator，这个方法返回一个具有迭代行为</span></span><br><span class="line"><span class="comment">* 的对象（比如：对象有next()方法，同时next方法返回一个包含value和done的对象</span></span><br><span class="line"><span class="comment">* ），那么这个类就是可迭代的*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages.push(&#123;message, timestamp: Date.now()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messages.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">log</span> = <span class="keyword">new</span> Log();</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"first day at sea"</span>);</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"spotted whale"</span>);</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"spotted another vessel"</span>);</span><br><span class="line"><span class="keyword">for</span> (let i of <span class="built_in">log</span>) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i.message&#125; @ $&#123;i.timestamp&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以编写自己的迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log2</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages.push(&#123;message, timestamp: Date.now()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> messages = <span class="keyword">this</span>.messages;</span><br><span class="line">        let i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= messages.length)</span><br><span class="line">                    <span class="keyword">return</span> &#123;value: undefined, done: <span class="literal">true</span>&#125;;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> &#123;value: messages[i++], done: <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">const</span> log2 = <span class="keyword">new</span> Log2();</span><br><span class="line">log2.add(<span class="string">"first day at sea"</span>);</span><br><span class="line">log2.add(<span class="string">"spotted whale"</span>);</span><br><span class="line">log2.add(<span class="string">"spotted another vessel"</span>);</span><br><span class="line"><span class="keyword">for</span> (let i of log2) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i.message&#125; @ $&#123;i.timestamp&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*至此，以上使用的例子都是迭代预先定义好元素个数的数组：一本书的页数，或者log中</span></span><br><span class="line"><span class="comment">* 的日期消息记录。迭代器还可以用来表示含有无穷值的对象。*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciSequence</span> &#123;</span></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        let a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                let temp = b;</span><br><span class="line">                b += a;</span><br><span class="line">                a = temp;</span><br><span class="line">                <span class="keyword">return</span> &#123;value: temp, done: <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fib = <span class="keyword">new</span> FibonacciSequence();</span><br><span class="line">let i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (let n of fib) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (++i &gt; <span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IIEFs和异步代码</span></span><br><span class="line"><span class="comment">/*setTimeout函数会根据第二个参数设置的时间延迟执行第一个参数（一个函数）*/</span></span><br><span class="line"><span class="comment">// setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//     console.log("hello");</span></span><br><span class="line"><span class="comment">// &#125;,1500);</span></span><br><span class="line"><span class="comment">//有了这些知识储备，可以编写倒计时代码</span></span><br><span class="line">var j;</span><br><span class="line"><span class="comment">// for(j=5;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">//     setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//         console.log(j===0? "go!":j);</span></span><br><span class="line"><span class="comment">//     &#125;,(5-j)*1000);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">/*运行结果是6个-1 异步编程。。还没理解这里的setTimeout函数再循环中没有被调用他</span></span><br><span class="line"><span class="comment">们会在未来的某个时间点被调用。所以循环会正常运行，从5开始，到-1结束..而这发生</span></span><br><span class="line"><span class="comment">在函数被调用之前。所以，当函数被调用是j的值是-1。*/</span></span><br><span class="line"><span class="comment">/*for (j = 5; j &gt;= 0; j--) &#123;</span></span><br><span class="line"><span class="comment">    (function (j) &#123;</span></span><br><span class="line"><span class="comment">        setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">            console.log(j === 0 ? "go!" : j);</span></span><br><span class="line"><span class="comment">        &#125;, (5 - j) * 1000);</span></span><br><span class="line"><span class="comment">    &#125;)(j);//IIFE + 匿名函数 + 闭包解决问题</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">// for(let j=5;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">//     setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//         console.log(j===0? "go!":j);</span></span><br><span class="line"><span class="comment">//     &#125;,(5-j)*1000);</span></span><br><span class="line"><span class="comment">// &#125;/*for循环使用let关键字也可以解决作用域的问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数变量：函数被调用之前和其他变量一样是静态的，被调用的时候是动态的</span></span><br><span class="line"><span class="comment">* 凡是能够使用变量的地方，都可以使用函数，意味着除了变量的普通用法外，</span></span><br><span class="line"><span class="comment">* 还可以做这些事</span></span><br><span class="line"><span class="comment">* · 通过创建一个指向函数的变量来给函数起一个别名</span></span><br><span class="line"><span class="comment">* · 将函数放入数组中（可能混合其他类型的数据）</span></span><br><span class="line"><span class="comment">* · 将函数当作对象的属性</span></span><br><span class="line"><span class="comment">* · 将函数传入到另一个函数中</span></span><br><span class="line"><span class="comment">* · 从一个函数中返回一个函数</span></span><br><span class="line"><span class="comment">* · 从一个把函数当作参数的函数中返回一个函数*/</span></span><br><span class="line"><span class="comment">//别名</span></span><br><span class="line"><span class="function">function <span class="title">addThreeSquareAddFiveTakeSquareRoot</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">sqrt</span>(Math.<span class="built_in">pow</span>(x+<span class="number">3</span>,<span class="number">2</span>)+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f3 = addThreeSquareAddFiveTakeSquareRoot;</span><br><span class="line"><span class="keyword">const</span> answer = (f3(<span class="number">5</span>)+f3(<span class="number">2</span>))/f3(<span class="number">7</span>);</span><br><span class="line">console.<span class="built_in">log</span>(answer);</span><br><span class="line"><span class="comment">//数组中的函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">cos</span> = Math.<span class="built_in">cos</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">sin</span> = Math.<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">const</span> theta = Math.PI/<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> zoom = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> offset = [<span class="number">1</span>,<span class="number">-3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pipeline = [</span><br><span class="line">    function rotate(p)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: p.x * <span class="built_in">cos</span>(theta) - p.y * <span class="built_in">sin</span>(theta),</span><br><span class="line">            y: p.x * <span class="built_in">sin</span>(theta) + p.y * <span class="built_in">cos</span>(theta)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">function <span class="title">scale</span><span class="params">(p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x: p.x * zoom, y: p.y * zoom&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">function <span class="title">translate</span><span class="params">(p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x: p.x + offset[<span class="number">0</span>],y: p.y + offset[<span class="number">1</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> p = &#123;x: <span class="number">1</span>,y: <span class="number">1</span>&#125;;</span><br><span class="line">let p2 = p;</span><br><span class="line"><span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;pipeline.length;i++)&#123;</span><br><span class="line">    p2 = pipeline[i](p2);</span><br><span class="line">    console.<span class="built_in">log</span>(p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将函数传给函数</span></span><br><span class="line"><span class="comment">/*之前已经接触了很多将函数传给函数的例子。比如把函数传给setTimeout或forEach。这样做</span></span><br><span class="line"><span class="comment">* 的另一个原因是为了管理异步编程。实现异步执行的常见方法是将一个函数(通常叫回调函数)</span></span><br><span class="line"><span class="comment">* 传给另一个函数。该函数在闭包函数执行完成时被调用*/</span></span><br><span class="line"><span class="function">function <span class="title">sum</span><span class="params">(arr,f)</span> </span>&#123;</span><br><span class="line">    if(typeof f != 'function')f = x =&gt; x;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce((a,x) =&gt; a+=f(x),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span> + sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line">console.<span class="built_in">log</span>(sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],x =&gt; x*x));</span><br><span class="line">console.<span class="built_in">log</span>(sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],x =&gt; Math.<span class="built_in">pow</span>(x,<span class="number">3</span>)));</span><br><span class="line"><span class="comment">//在函数中返回函数(有点难理解)</span></span><br><span class="line"><span class="comment">// function sumOfSquares(arr) &#123;</span></span><br><span class="line"><span class="comment">//     return sum(arr,x =&gt; x*x);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function">function <span class="title">newSummer</span><span class="params">(f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr =&gt; sum(arr,f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sumOfSquares = newSummer(x =&gt; x*x);</span><br><span class="line"><span class="keyword">const</span> sumOfCubes = newSummer(x =&gt; Math.<span class="built_in">pow</span>(x,<span class="number">3</span>));</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>+sumOfSquares([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line">console.<span class="built_in">log</span>(sumOfCubes([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//14章 异步编程</span></span><br><span class="line"><span class="comment">/*JavaScript对异步编程的支持有三个不同的阶段：</span></span><br><span class="line"><span class="comment">回调(callback)阶段</span></span><br><span class="line"><span class="comment">* promise阶段</span></span><br><span class="line"><span class="comment">* 生成器(generator)阶段*/</span></span><br><span class="line"><span class="comment">/*如果知识简单的说生成器比任何出现在它之前的阶段都好，那么只要了解生成</span></span><br><span class="line"><span class="comment">* 器的工作原理跳过其他的就行了，但实际上没这么简单。生成器本身并不提供</span></span><br><span class="line"><span class="comment">* 任何对异步的支持：他们依赖于承诺或特定类型的回调来提供异步行为。同样</span></span><br><span class="line"><span class="comment">* 像承诺这样有用的东西，会依赖于回调（而回调本身又由于具有对象而变得更</span></span><br><span class="line"><span class="comment">* 有用）。除了用户输入外，异步编程技术的三个主要使用场景是：</span></span><br><span class="line"><span class="comment">* 网络请求（如Ajax请求）</span></span><br><span class="line"><span class="comment">* 文件系统操作（读/写文件等）</span></span><br><span class="line"><span class="comment">* 刻意的时间延迟功能（比如警告等）*/</span></span><br><span class="line"><span class="comment">/*类比：在一个人满为患且没有预定的餐厅里找一个空桌子。此时不需要排队等</span></span><br><span class="line"><span class="comment">* ，当有位子的时候餐厅会给打电话。这就类似回调：给餐厅的工作人员提供了</span></span><br><span class="line"><span class="comment">* 一些信息，允许他们在有位子的时候通知客户。所以餐厅可以做自己的事，客</span></span><br><span class="line"><span class="comment">* 户也可以做自己的事，没有人在等其他人。另一家餐厅也许会给客户一个传呼</span></span><br><span class="line"><span class="comment">* 机，在位子准备好的时候就会响。这更像是一个承诺：餐厅工作人员会给客户</span></span><br><span class="line"><span class="comment">* 一个承诺，承诺在有空桌子的时候通知客户。*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Script学习记录 异步深入</title>
    <url>/posts/5be64662.html</url>
    <content><![CDATA[<blockquote>
<p>想吐槽一下，这个部分有点恶心 太绕了。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"Before timeout: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"After timeout: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"I happen after setTimeout"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"Me too"</span>);</span><br><span class="line"><span class="comment">/*可以看到代码编写的顺序与实际执行的顺序之间没有必然联系。这里就是回调异步*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//setInterval函数每隔一段特定的时间运行回调函数，并且一直运行下去，直到调用</span></span><br><span class="line"><span class="comment">//clearInterval函数</span></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> Date();</span><br><span class="line">let i_1 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> intervalId = setInterval(function () &#123;</span><br><span class="line">    let now = <span class="keyword">new</span> Date();</span><br><span class="line">    ++i_1;</span><br><span class="line">    <span class="keyword">if</span>(now.getMinutes() !== start.getMinutes() || i_1&gt;<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> clearInterval(intervalId);</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i_1&#125;: $&#123;now&#125;`);</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line"><span class="comment">/*setInterval返回了一个ID,在后面可以用来取消这次调用。与之对应的clearInterval</span></span><br><span class="line"><span class="comment">* 在timeout之前停止本次调用也是使用了这种方式</span></span><br><span class="line"><span class="comment">* setTimeout、setInterval、clearInterval都定义在全局对象中（浏览器中是window,</span></span><br><span class="line"><span class="comment">* Node中是global）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//scope和异步执行</span></span><br><span class="line"><span class="comment">/*异步执行中容易让人疑惑或犯错的一点是：scope和闭包是如何影响异步执行的。每当</span></span><br><span class="line"><span class="comment">* 一个函数被执行时，都创建了一个闭包：所有在函数内部创建的变量(包括形参)只在</span></span><br><span class="line"><span class="comment">* 有被访问的是时候才存在*/</span></span><br><span class="line"><span class="function">function <span class="title">contdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"Countdown:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(let i=<span class="number">5</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(i===<span class="number">0</span>?<span class="string">"Go!"</span>:i);</span><br><span class="line">        &#125;,(<span class="number">5</span>-i)*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contdown();</span><br><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="comment">/*创建一个带有函数的promise实例，它应该包含一个resolve(满足)和reject的回调。*/</span></span><br><span class="line"><span class="function">function <span class="title">countdown_</span><span class="params">(seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve,reject) &#123;</span><br><span class="line">        <span class="keyword">for</span>(let i=seconds;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">                <span class="keyword">if</span>(i===<span class="number">13</span>)<span class="keyword">return</span> reject(<span class="keyword">new</span> Error(<span class="string">"DEFINITELY NOT COUNTING THAT"</span>));</span><br><span class="line">                if(i&gt;0)console.log(i+'...');</span><br><span class="line">                <span class="keyword">else</span> resolve(console.<span class="built_in">log</span>(<span class="string">"Go"</span>));</span><br><span class="line">            &#125;,(seconds-i)*<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">countdown_(<span class="number">5</span>);</span><br><span class="line">使用promise</span><br><span class="line">countdown_(<span class="number">14</span>).then(</span><br><span class="line">    function () &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"countdown completed successfully"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"countdown experienced an error: "</span>+err.message);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*从小于13的任何数字开始倒数都不会出错，从13或大于13的数字开始，则会在数到13的时候</span></span><br><span class="line"><span class="comment">* 会出错，但是控制台会一直打印log。调用reject并没能终止函数，他们只是修改了promise</span></span><br><span class="line"><span class="comment">* 的状态。显然countdown函数需要优化。通常，并不希望一个函数在被处理后还能继续运行</span></span><br><span class="line"><span class="comment">* (不管成功还是失败)，单数countdown却继续运行。控制台的log一点都不灵活，他们并不会</span></span><br><span class="line"><span class="comment">* 真的提供想要的控制权。</span></span><br><span class="line"><span class="comment">* promise提供了一个定义及其良好，并且可以安全地处理那些满足或者拒绝的异步任务的方式</span></span><br><span class="line"><span class="comment">* ，但是它却没有报告过程进度的能力。也就是说，promise只可能是满足或者拒绝，绝不会出</span></span><br><span class="line"><span class="comment">* 现“%50完成”。有的promise库中增加了一些很有用的功能，比如，可以报告过程,很可能</span></span><br><span class="line"><span class="comment">* JavaScript中的promise也会具备那些功能，不过现在，我们只能在没有这些功能的情况下</span></span><br><span class="line"><span class="comment">* 工作。如果想要这些功能，需要继续学习下面的内容*/</span></span><br><span class="line"><span class="comment">//事件</span></span><br><span class="line"><span class="comment">/*事件发射器可以广播事件，任意愿意监听这些事件的人都可以去做这件事。如何监听事件呢？</span></span><br><span class="line"><span class="comment">* 答案是回调。创建自己的事件系统其实很简单，即便如此，Node还是为我们提供了内建的支持</span></span><br><span class="line"><span class="comment">* 。如果使用浏览器，jQuery同样提供了一个事件机制（http://api.jquery.com/category/events）</span></span><br><span class="line"><span class="comment">* 。为了改进countdown，我们通常会Node的EvenEmitter。虽然也可以在像countdown这样的</span></span><br><span class="line"><span class="comment">* 函数中使用EventEmitter,不过实际上他的设计初衷时跟类一起使用。所以可以把countdown</span></span><br><span class="line"><span class="comment">* 函数放在Countdown类中。*/</span></span><br><span class="line">const EventEmitter = require('events').EventEmitter;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> <span class="title">extends</span> <span class="title">EventEmitter</span>&#123;</span></span><br><span class="line">    constructor (seconds,superstitious)&#123;</span><br><span class="line">        super();</span><br><span class="line">        <span class="keyword">this</span>.seconds = seconds;</span><br><span class="line">        <span class="keyword">this</span>.superstitious = superstitious;</span><br><span class="line">    &#125;</span><br><span class="line">    go()&#123;</span><br><span class="line">        <span class="keyword">const</span> countdown = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve,reject) &#123;</span><br><span class="line">            <span class="keyword">for</span>(let i=countdown.seconds;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">                    <span class="keyword">if</span>(countdown.superstitious &amp;&amp; i===<span class="number">13</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> reject(<span class="keyword">new</span> Error(<span class="string">"DEFINITELY NOT COUNTING THAT"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    countdown.emit('tick',i);</span><br><span class="line">                    <span class="keyword">if</span>(i===<span class="number">0</span>)resolve();</span><br><span class="line">                &#125;,(countdown.seconds-i)*<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Countdown类继承了EventEmitter,这样Countdown就可以发射事件。Go方法是正式开始倒计时</span></span><br><span class="line"><span class="comment">* 并返回promise的地方。注意在go函数中，我们做的第一件事就是把this赋给countdown。这</span></span><br><span class="line"><span class="comment">* 是应为在回调中，不论倒计时是否迷信数字，都需要this的值来获取倒计时的长度。要记住</span></span><br><span class="line"><span class="comment">* this是一个特殊变量，它与回调中的this不是同一个东西。所以我们需要保存当前的this值，</span></span><br><span class="line"><span class="comment">* 从而在promise中使用它。任何想要监听tick事件（可以任意命名）的人都可以监听它。接下</span></span><br><span class="line"><span class="comment">* 来看看如何使用这经过改进后的全新countdown。*/</span></span><br><span class="line"><span class="keyword">const</span> c_1 = <span class="keyword">new</span> Countdown(<span class="number">13</span>);</span><br><span class="line">c_1.on('tick',function (i) &#123;</span><br><span class="line">    if(i&gt;0)console.log(i+'...');</span><br><span class="line">&#125;);</span><br><span class="line">c_1.go().then(function () &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"Go"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">catch</span>(function (err) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(err.message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode329矩阵中的最长递增路径</title>
    <url>/posts/410e261c.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数矩阵，找出最长递增路径的长度。<br>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。（就是非常经典的滑雪题）</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums =</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 最长递增路径为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>]。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums =</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 最长递增路径是 [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix</a></li>
</ul>
<blockquote>
<p>思路比较简单就是深搜+记忆化搜索</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y]!=<span class="number">-1</span>)<span class="keyword">return</span> f[x][y];<span class="comment">//记忆化</span></span><br><span class="line">        f[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = x+dx[i],b=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;n&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;m&amp;&amp;matrix[x][y]&gt;matrix[a][b])</span><br><span class="line">                f[x][y] = <span class="built_in">max</span>(f[x][y],dp(a,b,matrix)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>(),m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,dp(i,j,matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包总结</title>
    <url>/posts/2b28a584.html</url>
    <content><![CDATA[<blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第i件物品的体积是 vi，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>输入格式<br>第一行两个整数N，V，用空格隔开，分别表示物品数量和背包容积。<br>接下来有 N 行，每行两个整数 vi,wi用空格隔开，分别表示第 i 件物品的体积和价值。<br>输出格式<br>输出一个整数，表示最大价值。<br>数据范围</p>
</blockquote>
<p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路：今天太晚了，明天补上。三种方法，依次进行优化<br>增补：F[i,j]表示从前i个物品中选出了总体积为j的物品放入背包，物品的最大价值和。<br>F[i,j]=max(F[i-1,j],F[i-1,j-vi]+wi)<br>初值F[0,0]=0,其余负无穷，目标：max{F[N][j]} 0&lt;=j&lt;=m<br>//最朴素的做法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[N+<span class="number">1</span>][V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=V;j++)&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[N][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>//使用滚动数组的做法<br>通过DP的状态转移方程，可以发现，每一阶段i的状态只与上一阶段i-1的状态有关。这种情况下，可以使用滚动数组的优化方法，降低空间开销。把阶段i的状态存储在第一位下标为i&amp;1的二维数组中。当i为奇数时，i&amp;1=1；当i为偶数时，i&amp;1=0;因此，DP的状态就相当于在F[0][]和F[1][]两个数组中交替转移，空间复杂度从O(nm)降低为O(m)。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">2</span>][V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=V;j++)&#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j]=<span class="built_in">max</span>(f[i&amp;<span class="number">1</span>][j],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[N&amp;<span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>//线性空间做法<br>进一步分析上面代码，容易发现在每个阶段开始时，实际上执行了一次从F[i-1][]到F[i][]的拷贝操作。这提示我们可以进一步省略调F数组的第一维，只用一维数组，即当外层循环到第i个物品时，F[j]表示背包中放入总体积为j的物品的最大价值和。请注意下述代码使用了倒序循环。循环到j时：<br>1.F数组的后半部分F[jm]处于第i阶段，也就是已经考虑过放入第i个物品的情况。<br>2.前半部分F[0j-1]处于第i-1阶段，也就是没有第i个物品更新。<br>接下来j不断减小，意味着我们总是用第i-1阶段的状态向第i个阶段状态转移。<br>如果使用正序循环，假设F[j]被F[j-vi]+wi更新，接下来j增大到j+vi时，F[j+vi]又可能被F[j]+wi更新。此时，两个都处于第i个状态的状态之间发生了转移，相当于第i个物品被使用了两次。所以，必须使用倒序循环才符合0/1背包问题中每个物品是唯一的，只能放入背包一次。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)ans = <span class="built_in">max</span>(ans,f[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-50-Pow-x-n</title>
    <url>/posts/89f24699.html</url>
    <content><![CDATA[<blockquote>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2.00000</span>, <span class="number">10</span></span><br><span class="line">输出: <span class="number">1024.00000</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2.10000</span>, <span class="number">3</span></span><br><span class="line">输出: <span class="number">9.26100</span></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2.00000</span>, <span class="number">-2</span></span><br><span class="line">输出: <span class="number">0.25000</span></span><br><span class="line">解释: <span class="number">2</span><span class="number">-2</span> = <span class="number">1</span>/<span class="number">22</span> = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n 是 32 位有符号整数，其数值范围是([-2^{31},2^{31}-1]) 。</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/powx-n" target="_blank" rel="noopener">https://leetcode-cn.com/problems/powx-n</a></li>
</ul>
<blockquote>
<p>思路：思路：快速幂模板题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> b=<span class="built_in">abs</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans = ans * x;</span><br><span class="line">            x = x * x ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>/ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode题解167,88,155,32,84,42</title>
    <url>/posts/81be5994.html</url>
    <content><![CDATA[<blockquote>
<p>练习了一下双指针，单调栈。三道简单，三道困难。分别是两数之和 II - 输入有序数组，合并两个有序数组，最小栈，最长有效括号，柱状图中最大的矩形，接雨水。难度着实有点大。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>两数之和<br>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br>示例:<br>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a></li>
</ul>
<blockquote>
<p>思路：利用单调性使用双指针，可以想到假设(i&gt;j)nums[i]+nums[j]&gt;=target,<br>对于特定的j，i是使这个不等式成立的最小下标，则当j增大时，i必然减小或者不变。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i<span class="number">-1</span>&gt;j&amp;&amp;nums[i<span class="number">-1</span>]+nums[j]&gt;=target)i--;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]==target)<span class="keyword">return</span> &#123;j+<span class="number">1</span>,i+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>合并连个有序数组:<br>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>说明:</p>
</blockquote>
<ol>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li>
<li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<blockquote>
<p>示例:<br>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6], n = 3<br>输出: [1,2,2,3,5,6]</p>
</blockquote>
</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array</a></li>
</ul>
<blockquote>
<p>思路：非常简单啦，考研复习时王道上面就有这个题，不多解释了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=m<span class="number">-1</span>,j=n<span class="number">-1</span>,k=n+m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&gt;nums2[j])nums1[k--]=nums1[i--];</span><br><span class="line">            <span class="keyword">else</span> nums1[k--]=nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)nums1[k--]=nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最小栈：<br>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
</blockquote>
<ul>
<li><p>push(x) – 将元素 x 推入栈中。</p>
</li>
<li><p>pop() – 删除栈顶的元素。</p>
</li>
<li><p>top() – 获取栈顶元素。</p>
</li>
<li><p>getMin() – 检索栈中的最小元素。<br>示例:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin(); –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top(); –&gt; 返回 0.<br>minStack.getMin(); –&gt; 返回 -2.</p>
</li>
<li><p>来源：力扣（LeetCode）</p>
</li>
<li><p>链接：<a href="https://leetcode-cn.com/problems/min-stack" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack</a></p>
</li>
</ul>
<blockquote>
<p>思路：比较简单，维护两个栈，注意在插入时，如果保存最小元素的栈空，则直接插入，否则最小栈插入当前带插入元素和栈顶元素的小者。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;stkmin,stk;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">if</span>(stkmin.empty())stkmin.push(x);</span><br><span class="line">        <span class="keyword">else</span> stkmin.push(<span class="built_in">min</span>(x,stkmin.top()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.pop();</span><br><span class="line">        stkmin.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stkmin.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重头戏来了。。<br>最长有效括号：<br>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。<br>示例 1:<br>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:<br>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses</a></li>
</ul>
<blockquote>
<p>思路：要用到一些关于括号匹配的性质。如果括号序列有效，则对于每个括号，其对应的括号是固定的。比如(())，第1个括号必然对应第4个括号，第2个括号必然对应第3个括号，反之亦然。还有一个性质就是，如果一个括号序列合法，将左括号看作1，右括号看作-1，则这个序列的前缀和都大于0，且总和为0。但是还要考虑一下左括号比右括号多的情况，因此要反着考虑一遍。所以可以想到：cnt作为前缀和，碰到左括号则cnt++,否则cnt–，如果cnt&lt;0,则要从当前元素的下一个位置重新开始，并置cnt为0。为什么start不是从start+1而是从i+1开始呢，这个就用到了第一个性质，如果cnt&lt;0,则start到i不可能会有合法序列。如果cnt==0，说明找到了一个新的合法序列。返回最大值即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,start=<span class="number">0</span>,cnt=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>)cnt++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span>(cnt&lt;<span class="number">0</span>)start=i+<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">0</span>)res=<span class="built_in">max</span>(res,i-start+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = work(s);</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)c^=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res,work(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>柱状图中最大矩形：<br>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="https://ae01.alicdn.com/kf/H60940b1e41cf461b9837212a24b35b582.png" alt=""><br>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。<br><img src="https://ae01.alicdn.com/kf/H3af88c1f70e349b2b6fa5ed63cd25d16L.png" alt=""></p>
</blockquote>
<blockquote>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。<br>示例:<br>输入: [2,1,5,6,2,3]<br>输出: 10</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram</a></li>
</ul>
<blockquote>
<p>思路：单调栈（找到每个柱子的左右两边第一个小于自己高度的柱子）。根据每个柱子的高度来找到左右两边第一个小于自己高度的柱子存在left和right中，枚举每个柱子能画出的最大面积$(height[i]*(right[i]-left[i]-1))$。</p>
<ol>
<li>如果栈不为空，且栈顶元素大于当前元素则出栈(不可能成为候选者)</li>
<li>如果栈为空则left(i)(或者right(i))赋为-1（或者n）否则赋为栈顶值</li>
<li>当前元素进栈</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;left(n),right(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;heights[s.top()]&gt;=heights[i])s.pop();</span><br><span class="line">            <span class="keyword">if</span>(s.empty())left[i]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left[i]=s.top();</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>())s.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;heights[s.top()]&gt;=heights[i])s.pop();</span><br><span class="line">            <span class="keyword">if</span>(s.empty())right[i]=n;</span><br><span class="line">            <span class="keyword">else</span> right[i]=s.top();</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)res = <span class="built_in">max</span>(res,heights[i]*(right[i]-left[i]<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接雨水：<br>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="https://ae01.alicdn.com/kf/H3e93ddc033774db4bb03c73c76403220l.png" alt=""><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。<br>示例:<br>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p>
</blockquote>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trapping-rain-water</a></li>
</ul>
<blockquote>
<p>思路：单调栈。关键在于找出雨水的面积求法。可以按层叠加。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">height</span>.<span class="built_in">size</span>(),res=<span class="number">0</span>,last;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;<span class="built_in">height</span>[s.top()]&lt;=<span class="built_in">height</span>[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> t = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                res+=(i-t<span class="number">-1</span>)*(<span class="built_in">height</span>[t]-last);</span><br><span class="line">                last = <span class="built_in">height</span>[t];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>())res+=(i-s.top()<span class="number">-1</span>)*(<span class="built_in">height</span>[i]-last);</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>双指针</category>
        <category>栈</category>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>多重背包</title>
    <url>/posts/4651617g.html</url>
    <content><![CDATA[<blockquote>
<p>多重背包模型如下：<br>有 N 种物品和一个容量是 M 的背包。第 i 种物品最多有 \(C_i\) 件，每件体积是 \(V_i\)，价值是 \(W_i\)。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</p>
</blockquote>
<a id="more"></a>
<p>思路:<br>直接拆分法，求解多重背包问题最直接的方法是把第i种物品当作独立的\(C_i\)个物品，转化为共\(\sum_{i=1}^{N}C_i\)个物品的0/1背包问题进行计算，时间复杂度为复杂度\(O(M*\sum_{i=1}^{N}C_i)\)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> f[MAX_M+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">memset</span>(f,oxcf,<span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c[i];j++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> k=m;k&gt;=v[i];k--)&#123;</span><br><span class="line">            f[k]=<span class="built_in">max</span>(f[k],f[k-v[i]]+w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=m;i++)ans = <span class="built_in">max</span> (ans,f[i]);</span><br></pre></td></tr></table></figure>
<p>使用二进制优化<br>其实不用把c[i]个物品分成单独的01背包，可以使用二进制表示<br>如：s = 10 = 1 + 2 + 4 + 3<br>所以可以拆分成V=1<em>v,W=1</em>w, V=2<em>v,W=2</em>w, V=4<em>v,W=4</em>w, V=3<em>v,W=3</em>w的01背包<br>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goods</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Goods&gt;goods;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=s;k*=<span class="number">2</span>)&#123;</span><br><span class="line">            goods.push_back(&#123;k*v,k*w&#125;);</span><br><span class="line">            s-=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)goods.push_back(&#123;s*v,s*w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> g:goods)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=g.v;j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-g.v]+g.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用单调队列优化：这个坑还没补上，还没看懂</p>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode322零钱兑换</title>
    <url>/posts/89f24625.html</url>
    <content><![CDATA[<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>说明: 你可以认为每种硬币的数量是无限的。</li>
</ul>
<blockquote>
<p>思路：经典的dp问题，完全背包。得找个时间把背包九讲复习整理一遍。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f(amount+<span class="number">1</span>,INT_MAX/<span class="number">2</span>);</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = c;i&lt;=amount;i++)&#123;</span><br><span class="line">                f[i] = <span class="built_in">min</span>(f[i],f[i-c]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[amount]==INT_MAX/<span class="number">2</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>完全背包</title>
    <url>/posts/4651617h.html</url>
    <content><![CDATA[<blockquote>
<p>完全背包问题的模型如下：<br>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。第 i 种物品的体积是 \(V_i\)，价值是 \(W_i\)。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<a id="more"></a>


<blockquote>
<p>输入格式<br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。接下来有 N 行，每行两个整数 \(V_i\),\(W_i\)，用空格隔开，分别表示第 i 种物品的体积和价值。<br><br>输出格式<br>输出一个整数，表示最大价值。<br>数据范围<br>0&lt;N,V≤1000<br>0&lt;$V_i$,$W_i$≤1000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例</span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>思路：先考虑使用传统的二维线性DP的做法。设F[i,j]表示从前i种物品中选出了总体积为j的物品放入背包，物品的最大价值和。<br>$F[i,j] = max(F[i-1,j],F[i-1,j-V_i]+W_i)$<br>初值:$F[0,0]=0$,其余均为负无穷。目标：$max(F[N][j])$。<br>与0/1背包一样，我们也可以省略F数组的i这一维。根据我们在0/1背包中对循环顺序的分析，当采用正序循环时，就对应着每种物品可以使用无限次，也对应着$F[i,j] = F[i,j-V_i]+W_i$这个在两个均处于i阶段的状态之间进行转移的方程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V,v=<span class="number">0</span>,w=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[V+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v,&amp;w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&lt;=V;j++)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)ans = <span class="built_in">max</span>(ans,f[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔2</title>
    <url>/posts/4651617f.html</url>
    <content><![CDATA[<blockquote>
<p>今天突然心血来潮想换个ide写算法题，试了vscode和visual studio,笔记本性能比较一般，运行VS会卡顿。。所以还是选择了visual studio code，不过这玩意儿只是个编辑器，还需要自己配置编译器，下插件，麻烦死了，花了老半天功夫才弄好，一直无法调试，一调试程序就崩溃了，后来改了很多配置文件才弄好，把配置文件贴在这里好了（我的服务器之前欠费宕机了，今天花了点时间又整了一下，顺便买了个域名，弄了一下域名备案，不知道啥时候可以备下来hhh）。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>先下载安装vscode，按ctrl+shift+x,搜索c++,安装<br><img src="https://ae01.alicdn.com/kf/H5897989a61d947088d3a814c4d56c7282.png" alt=""><br>再搜索code run,安装<br><img src="https://ae01.alicdn.com/kf/Hebff0b70113f4aadb056b2e15a78d011k.png" alt=""><br>（还需要下载MinGW点击下载）打开MinGW安装器界面，勾选一下几个选项（右键Make for Installation进行标记）：</p>
</blockquote>
<blockquote>
<ol>
<li>minGW32-gcc(bin)</li>
<li>minGW32-gcc-g++(bin)</li>
<li>minGW32-gdb(bin)</li>
</ol>
</blockquote>
<blockquote>
<p>点击左上角的Installation菜单下的Apply Changes以应用修改，过程需要联网，安装完成后需要为环境变量配置Path，添加E:\MinGW\bin。<br>此时重新启动VSCode，编译完代码后按快捷键F5或者在菜单栏中找到调试按钮以进行调试操作。<br>注意vscode调试需要在打开的文件夹中进行，可以在资源管理器中创建一个文件夹来保存临时代码文件。<br>打开文件夹，创建一个.cpp文件，编写一段helloworld代码，创建一个.vscode文件夹。结构如下图：<br><img src="https://ae01.alicdn.com/kf/H7e95cc578c074334aa6f283bf1d7d58fw.png" alt=""><br>在.vscode中创建四个.json文件：</p>
</blockquote>
<p>c_cpp_properties.json</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Win32"</span>,</span><br><span class="line">            <span class="string">"includePath"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"defines"</span>: [</span><br><span class="line">                <span class="string">"_DEBUG"</span>,</span><br><span class="line">                <span class="string">"UNICODE"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"compilerPath"</span>: <span class="string">"E:\\MinGW\\bin\\g++.exe"</span>,		</span><br><span class="line">            <span class="string">"intelliSenseMode"</span>: <span class="string">"msvc-x64"</span>,</span><br><span class="line">            <span class="string">"browse"</span>: &#123;</span><br><span class="line">                <span class="string">"path"</span>: [</span><br><span class="line">                    <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"limitSymbolsToIncludedHeaders"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"databaseFilename"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"cStandard"</span>: <span class="string">"c11"</span>,</span><br><span class="line">            <span class="string">"cppStandard"</span>: <span class="string">"c++17"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compilerPath的路径与安装的WinGW的c++环境对应，其他不用改。</span></span><br></pre></td></tr></table></figure>
<p>launch.json</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。</span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"(gdb) Launch"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.exe"</span>,	<span class="comment">//要运行的文件</span></span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="string">"miDebuggerPath"</span>: <span class="string">"E:\\MinGW\\bin\\gdb.exe"</span>,</span><br><span class="line">            <span class="string">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="string">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="string">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"complie"</span> <span class="comment">// 调试会话开始前执行的任务，类似于Ant，这里为我们的编译任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//miDebuggerPath这个也要改。</span></span><br></pre></td></tr></table></figure>
<p>settings.json</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"files.associations"</span>: &#123;</span><br><span class="line">        <span class="string">"iostream"</span>: <span class="string">"cpp"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tasks.json</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="string">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"label"</span>: <span class="string">"complie"</span>,			<span class="comment">//任务名</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="string">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [</span><br><span class="line">                <span class="comment">// Ask msbuild to generate full paths for file names.</span></span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileBasename&#125;"</span>,</span><br><span class="line">                <span class="string">"-o"</span>,</span><br><span class="line">                <span class="string">"$&#123;fileBasenameNoExtension&#125;.exe"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"presentation"</span>: &#123;</span><br><span class="line">                <span class="comment">// Reveal the output only if unrecognized errors occur.</span></span><br><span class="line">                <span class="string">"reveal"</span>: <span class="string">"always"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// Use the standard MS compiler pattern to detect errors, warnings and infos</span></span><br><span class="line">            <span class="string">"problemMatcher"</span>: <span class="string">"$msCompile"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样就完成了配置，可以尽情的玩耍了。<br>去中南的oj逛了逛感觉那些同学的做题热情不够哇。。除了排名最靠前的几个同学，后面的同学刷的比较少。顺手注册A了几个题hhh<br><img src="https://ae01.alicdn.com/kf/H4c053fe50fc949168066a53a5139f5f85.png" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode486预测赢家</title>
    <url>/posts/4651617d.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。<br>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">输出: False</span><br><span class="line">解释: 一开始，玩家<span class="number">1</span>可以从<span class="number">1</span>和<span class="number">2</span>中进行选择。</span><br><span class="line">如果他选择<span class="number">2</span>（或者<span class="number">1</span>），那么玩家<span class="number">2</span>可以从<span class="number">1</span>（或者<span class="number">2</span>）和<span class="number">5</span>中进行选择。如果玩家<span class="number">2</span>选择了<span class="number">5</span>，那么玩家<span class="number">1</span>则只剩下<span class="number">1</span>（或者<span class="number">2</span>）可选。</span><br><span class="line">所以，玩家<span class="number">1</span>的最终分数为 <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span>，而玩家<span class="number">2</span>为 <span class="number">5</span>。</span><br><span class="line">因此，玩家<span class="number">1</span>永远不会成为赢家，返回 False。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">233</span>, <span class="number">7</span>]</span><br><span class="line">输出: True</span><br><span class="line">解释: 玩家<span class="number">1</span>一开始选择<span class="number">1</span>。然后玩家<span class="number">2</span>必须从<span class="number">5</span>和<span class="number">7</span>中进行选择。无论玩家<span class="number">2</span>选择了哪个，玩家<span class="number">1</span>都可以选择<span class="number">233</span>。</span><br><span class="line">最终，玩家<span class="number">1</span>（<span class="number">234</span>分）比玩家<span class="number">2</span>（<span class="number">12</span>分）获得更多的分数，所以返回 True，表示玩家<span class="number">1</span>可以成为赢家。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:</p>
</blockquote>
<ol>
<li>1 &lt;= 给定的数组长度 &lt;= 20.</li>
<li>数组里所有分数都为非负数且不会大于10000000。</li>
<li>如果最终两个玩家的分数相等，那么玩家1仍为赢家。</li>
</ol>
<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/predict-the-winner" target="_blank" rel="noopener">https://leetcode-cn.com/problems/predict-the-winner</a></li>
</ul>
<blockquote>
<p>思路：（区间dp问题，一般都要先枚举区间长度）。状态定义：f[i][j表示取完了除i-j区间外所有数，先手玩家可得最高分数。初始化时如果数组的数为奇数个则最后一次是先手玩家取数，若为偶数则啥也不干。枚举区间长度2-n，l表示区间左端点，r表示区间右端点。若当前取的数是第奇数个则是先手玩家取，故要采取对自己最有利的方式,从左右端点中取最大的那个数，状态转移方程为:<br>$f[l][r] = max(f[l+1][r] + nums[l],f[l][r-1]+nums[r])$<br>否则是对方取数，则会让先手玩家得分为最小，状态转移方程为：<br>$f[l][r] = min(f[l+1][r],f[l][r-1])$<br>（因为f[i][j]是先手玩家能得最大分）<br>由于若两个玩家最后的分数相等也是先手玩家赢，所以最后要比较一下先手玩家和后手玩家的分数。<br>代码如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i][i] = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i&lt;=n; i++)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j+i<span class="number">-1</span>&lt;n;j++)&#123;<span class="comment">//f[i][j]表示取完了除i-j区间之后 玩家可得最高分数</span></span><br><span class="line">                <span class="keyword">int</span> l = j, r = i+j<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>((n-(r-l+<span class="number">1</span>))%<span class="number">2</span>==<span class="number">0</span>)f[l][r] = <span class="built_in">max</span>(f[l+<span class="number">1</span>][r] + nums[l],f[l][r<span class="number">-1</span>]+nums[r]);</span><br><span class="line">                <span class="keyword">else</span> f[l][r] = <span class="built_in">min</span>(f[l+<span class="number">1</span>][r],f[l][r<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;n;i++)sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">0</span>][n<span class="number">-1</span>]&gt;=sum-f[<span class="number">0</span>][n<span class="number">-1</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode357计算各个位数不同的数字个数</title>
    <url>/posts/52d85e26.html</url>
    <content><![CDATA[<blockquote>
<p>给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10^n 。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">91</span></span><br><span class="line">解释: 答案应为除去 <span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span> 外，在 [<span class="number">0</span>,<span class="number">100</span>) 区间内的所有数字。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路：这题第一感觉就是找规律…可以结合一些组合数学的知识然后dp解决。可以这样考虑，n限制了我们需要考虑的数的位数，稍微思考一下就可以得出如下结论，对于一个n位数，第一位数有9种选择（0要排除），第二位数不能和第一位数相同故有9种选择，第三位数不能和前两位数相同故有8种选择..依此类推到最后一位数，算完后要加上n-1位各个位数不同的数字个数(第一位是0的情况)。举例：n=1时各个位数不同的数字有10个，n=2时由上述过程各个位数不同的数字有9*9+10=91个。实现代码如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans[<span class="number">10</span>];</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">9</span>,k=<span class="number">1</span>;k&lt;i;k++)&#123;</span><br><span class="line">                temp = temp * j;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = temp * <span class="number">9</span> + ans[i<span class="number">-1</span>];            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/posts/4651617e.html</url>
    <content><![CDATA[<blockquote>
<p>27号放假在家咸鱼了将近20天所以鸽了近20天。。15号回学校了，可以继续跟新博客了hhh。今天主要学习了一点机器学习的东西。<br>(今天有个老同学来了，虽然啥也没干，也还是很开心的hhh)</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>了解了用于分类的线性模型<br>线性模型也广泛应用于分类问题。<br>$y=w[0]x[0]+w[1]x[1]+…+w[p]*x[p]+b&gt;0$<br>这个公式看起来与线性回归的公式非常相似，但我们没有返回特征的加权求和，而是为预测设置了阈值。如果函数值小于0，就预测类别为-1；如果函数值大于0，就预测类别为+1。对于所有用于分类的线性模型，这个预测规则都是通用的。同样，有很多种不同的方法来找出系数w和截距b。<br>对于用于回归的线性模型，输出y是特征的线性函数，是直线、平面或者超平面。对于用于分类的线性模型，决策边界是输入的线性模型。换句话说，线性分类器是利用直线、平面或超平面来分开两个类别的分类器。</p>
</blockquote>
<blockquote>
<p>学习线性模型有很多种算法。这些算法的区别在于以下两点：</p>
</blockquote>
<ul>
<li>系数和截距的特定组合对训练数据拟合好坏的度量方法；</li>
<li>是否使用正则化，以及使用哪种正则化方法</li>
</ul>
<blockquote>
<p>不同的算法使用不同的方法来度量“对训练集拟合的好坏”。由于数学上的技术原因，不可能调节w和b使得算法产生的误分类数量最少。<br>最常见的两种线性分类算法是Logistic回归（logistic regression）和线性支持向量机(SVM)，虽然含有回归，但其实是一种分类算法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">from sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">from sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">X,y=mglearn.datasets.make_forge()</span><br><span class="line">fig,axes=plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> model,ax in zip([LinearSVC(),LogisticRegression()],axes):</span><br><span class="line">    clf = model.fit(X,y)</span><br><span class="line">    mglearn.plots.plot_2d_separator(clf,X,<span class="built_in">fill</span>=False,eps=<span class="number">0.5</span>,ax=ax,alpha=<span class="number">.7</span>)</span><br><span class="line">    mglearn.discrete_scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],y,ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">"&#123;&#125;"</span>.format(clf.__class__.__name__))</span><br><span class="line">    ax.set_xlabel(<span class="string">"Feature 0"</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">"Feature 1"</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H119bded0afe546f2acd92aad58a13badX.png" alt=""></p>
<blockquote>
<p>图中，forge数据集的第一个特征位于x轴，第二个特征位于y轴，与前面相同。图中展示了LinearSVC和LogisticRegression得到的决策边界，都是直线，将顶部归为类别1的区域和底部归为类别0的区域分开了。换句话说，对于每个分类器而言，位于黑线上方的新数据点都会被化为类别1，下方化为类别0。<br>两个模型都默认使用L2正则化，就像Ridge对回归所做的那样。<br>对于LinearSVC和LogisticRegression，决定正则化强度的权衡参数叫做C。C值越大，对应的正则化越弱。换句话说，如果参数C值较大，那么LinearSVC和LogisticRegression将尽可能将训练集拟合到最好，而如果C值较小，那么模型更强调是系数向量接近于0。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy as np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line"><span class="keyword">import</span> pandas as pd</span><br><span class="line"><span class="keyword">import</span> mglearn</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">from sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">from sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line">X,y = mglearn.datasets.make_forge()</span><br><span class="line">fig,axes = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> model,ax in zip([LinearSVC(),LogisticRegression()],axes):</span><br><span class="line">    clf = model.fit(X,y)</span><br><span class="line">    mglearn.plots.plot_2d_separator(clf,X,<span class="built_in">fill</span> = False,eps=<span class="number">0.5</span>,ax=ax,alpha=<span class="number">.7</span>)</span><br><span class="line">    mglearn.discrete_scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],y,ax=ax)</span><br><span class="line">    ax.set_title(<span class="string">"&#123;&#125;"</span>.format(clf.__class__.__name__))</span><br><span class="line">    ax.set_xlabel(<span class="string">"Feature 0"</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">"Feature 1"</span>)</span><br><span class="line">axes[<span class="number">0</span>].legend()</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H052171b433bf4d0dbce937ea9cb48e62Y.png" alt=""></p>
<blockquote>
<p>较小的参数C可以让算法尽量适应“大多数”数据点，而较大的C值更强调每个数据点都分类正确的重要性。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line">from sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(</span><br><span class="line">    cancer.data,cancer.target,stratify=cancer.target,random_state=<span class="number">42</span>)</span><br><span class="line">logreg = LogisticRegression().fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Training set score:&#123;:.3f&#125;"</span>.format(logreg.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Test set score:&#123;:.3f&#125;"</span>.format(logreg.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line">Training <span class="built_in">set</span> score:<span class="number">0.955</span></span><br><span class="line">Test <span class="built_in">set</span> score:<span class="number">0.958</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">logreg100 = LogisticRegression(C=<span class="number">100</span>).fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Training set score:&#123;:.3f&#125;"</span>.format(logreg100.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Test set score:&#123;:.3f&#125;"</span>.format(logreg100.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line">Training <span class="built_in">set</span> score:<span class="number">0.972</span></span><br><span class="line">Test <span class="built_in">set</span> score:<span class="number">0.965</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">logreg001 = LogisticRegression(C=<span class="number">0.01</span>).fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Training set score:&#123;:.3f&#125;"</span>.format(logreg001.score(X_train,y_train)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Test set score:&#123;:.3f&#125;"</span>.format(logreg001.score(X_test,y_test)))</span><br><span class="line"></span><br><span class="line">Training <span class="built_in">set</span> score:<span class="number">0.934</span></span><br><span class="line">Test <span class="built_in">set</span> score:<span class="number">0.930</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">plt.plot(logreg.coef_.T,<span class="string">'o'</span>,label=<span class="string">"C=1"</span>)</span><br><span class="line">plt.plot(logreg100.coef_.T,<span class="string">'^'</span>,label=<span class="string">"C=100"</span>)</span><br><span class="line">plt.plot(logreg001.coef_.T,<span class="string">'v'</span>,label=<span class="string">"C=0.01"</span>)</span><br><span class="line">plt.xticks(range(cancer.data.shape[<span class="number">1</span>]),cancer.feature_names,rotation=<span class="number">90</span>)</span><br><span class="line">plt.hlines(<span class="number">0</span>,<span class="number">0</span>,cancer.data.shape[<span class="number">1</span>])</span><br><span class="line">plt.ylim(<span class="number">-5</span>,<span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Coefficient index"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Coefficient magnitude"</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hd05fa3d50a5545a4841c5376e01d6bb0E.png" alt=""></p>
<blockquote>
<p>用于多分类的线性模型<br>将二分类算法推广到多分类算法的常见方法是“一对其余”。对每个类别都学习一个二分类模型，将这个类别与所有其他类别尽量分别开，这样就生成了与类别个数一样多的二分类模型。在测试点上运行所有二分类器来进行预测。在对应类别上分数最高的分类器胜出。将这个类别标签返回作为预测结果。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">from sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line">X,y=make_blobs(random_state=<span class="number">42</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],y)</span><br><span class="line"><span class="built_in">line</span> = np.linspace(<span class="number">-15</span>,<span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> coef,intercept,color in zip(linear_svm.coef_,linear_svm.intercept_,[<span class="string">'b'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>]):</span><br><span class="line">    plt.plot(<span class="built_in">line</span>,-(<span class="built_in">line</span> * coef[<span class="number">0</span>]+intercept)/coef[<span class="number">1</span>],c=color)</span><br><span class="line">plt.ylim(<span class="number">-10</span>,<span class="number">15</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>,<span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Feature 0"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Feature 1"</span>)</span><br><span class="line">plt.legend(["Class 0","Class 1","Class 2",'Line class 0','Line class 1','Line class 2'],loc=(1.01,0.3))</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/H7f1732d69995409ca8e108894c8d29e1o.png" alt=""></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mglearn.plots.plot_2d_classification(linear_svm,X,<span class="built_in">fill</span>=True,alpha=<span class="number">.7</span>)</span><br><span class="line">mglearn.discrete_scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],y)</span><br><span class="line"><span class="built_in">line</span> = np.linspace(<span class="number">-15</span>,<span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> coef,intercept,color in zip(linear_svm.coef_,linear_svm.intercept_,[<span class="string">'b'</span>,<span class="string">'r'</span>,<span class="string">'g'</span>]):</span><br><span class="line">    plt.plot(<span class="built_in">line</span>,-(<span class="built_in">line</span> * coef[<span class="number">0</span>]+intercept)/coef[<span class="number">1</span>],c=color)</span><br><span class="line">plt.ylim(<span class="number">-10</span>,<span class="number">15</span>)</span><br><span class="line">plt.xlim(<span class="number">-10</span>,<span class="number">8</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Feature 0"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Feature 1"</span>)</span><br><span class="line">plt.legend(["Class 0","Class 1","Class 2",'Line class 0','Line class 1','Line class 2'],loc=(1.01,0.3))</span><br></pre></td></tr></table></figure>
<p><img src="https://ae01.alicdn.com/kf/Hf19136ef29e948c18e9c87109699b418V.png" alt=""></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
