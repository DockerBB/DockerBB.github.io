<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript迭代器和函数深入</title>
    <url>/2019/11/26/JavaScript%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<p>Js迭代器和函数深入</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器和生成器</span></span><br><span class="line"><span class="keyword">const</span> book = [</span><br><span class="line">    <span class="string">"Twinkle, twinkle, little bat!"</span>,</span><br><span class="line">    <span class="string">"How I wonder what you're at!"</span>,</span><br><span class="line">    <span class="string">"Up above the world you fly,"</span>,</span><br><span class="line">    <span class="string">"Like a tea tray in the sky."</span>,</span><br><span class="line">    <span class="string">"Twinkle, twinkle, little bat!"</span>,</span><br><span class="line">    <span class="string">"How I wonder what you're at!"</span></span><br><span class="line">];</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">const</span> it = book.values();<span class="comment">//values（）方法获取迭代器</span></span><br><span class="line"><span class="keyword">for</span> (let i = it.next(); !i.done; i = it.next()) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(i.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代协议</span></span><br><span class="line"><span class="comment">/*迭代器协议可以让任何对象变得可迭代</span></span><br><span class="line"><span class="comment">* 如果一个类提供了一个符号方法Symbol.iterator，这个方法返回一个具有迭代行为</span></span><br><span class="line"><span class="comment">* 的对象（比如：对象有next()方法，同时next方法返回一个包含value和done的对象</span></span><br><span class="line"><span class="comment">* ），那么这个类就是可迭代的*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages.push(&#123;message, timestamp: Date.now()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messages.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">log</span> = <span class="keyword">new</span> Log();</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"first day at sea"</span>);</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"spotted whale"</span>);</span><br><span class="line"><span class="built_in">log</span>.add(<span class="string">"spotted another vessel"</span>);</span><br><span class="line"><span class="keyword">for</span> (let i of <span class="built_in">log</span>) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i.message&#125; @ $&#123;i.timestamp&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以编写自己的迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log2</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messages.push(&#123;message, timestamp: Date.now()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> messages = <span class="keyword">this</span>.messages;</span><br><span class="line">        let i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= messages.length)</span><br><span class="line">                    <span class="keyword">return</span> &#123;value: undefined, done: <span class="literal">true</span>&#125;;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> &#123;value: messages[i++], done: <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">const</span> log2 = <span class="keyword">new</span> Log2();</span><br><span class="line">log2.add(<span class="string">"first day at sea"</span>);</span><br><span class="line">log2.add(<span class="string">"spotted whale"</span>);</span><br><span class="line">log2.add(<span class="string">"spotted another vessel"</span>);</span><br><span class="line"><span class="keyword">for</span> (let i of log2) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i.message&#125; @ $&#123;i.timestamp&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*至此，以上使用的例子都是迭代预先定义好元素个数的数组：一本书的页数，或者log中</span></span><br><span class="line"><span class="comment">* 的日期消息记录。迭代器还可以用来表示含有无穷值的对象。*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciSequence</span> &#123;</span></span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">        let a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                let temp = b;</span><br><span class="line">                b += a;</span><br><span class="line">                a = temp;</span><br><span class="line">                <span class="keyword">return</span> &#123;value: temp, done: <span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fib = <span class="keyword">new</span> FibonacciSequence();</span><br><span class="line">let i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (let n of fib) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (++i &gt; <span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IIEFs和异步代码</span></span><br><span class="line"><span class="comment">/*setTimeout函数会根据第二个参数设置的时间延迟执行第一个参数（一个函数）*/</span></span><br><span class="line"><span class="comment">// setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//     console.log("hello");</span></span><br><span class="line"><span class="comment">// &#125;,1500);</span></span><br><span class="line"><span class="comment">//有了这些知识储备，可以编写倒计时代码</span></span><br><span class="line">var j;</span><br><span class="line"><span class="comment">// for(j=5;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">//     setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//         console.log(j===0? "go!":j);</span></span><br><span class="line"><span class="comment">//     &#125;,(5-j)*1000);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">/*运行结果是6个-1 异步编程。。还没理解这里的setTimeout函数再循环中没有被调用他</span></span><br><span class="line"><span class="comment">们会在未来的某个时间点被调用。所以循环会正常运行，从5开始，到-1结束..而这发生</span></span><br><span class="line"><span class="comment">在函数被调用之前。所以，当函数被调用是j的值是-1。*/</span></span><br><span class="line"><span class="comment">/*for (j = 5; j &gt;= 0; j--) &#123;</span></span><br><span class="line"><span class="comment">    (function (j) &#123;</span></span><br><span class="line"><span class="comment">        setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">            console.log(j === 0 ? "go!" : j);</span></span><br><span class="line"><span class="comment">        &#125;, (5 - j) * 1000);</span></span><br><span class="line"><span class="comment">    &#125;)(j);//IIFE + 匿名函数 + 闭包解决问题</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">// for(let j=5;j&gt;=0;j--)&#123;</span></span><br><span class="line"><span class="comment">//     setTimeout(function () &#123;</span></span><br><span class="line"><span class="comment">//         console.log(j===0? "go!":j);</span></span><br><span class="line"><span class="comment">//     &#125;,(5-j)*1000);</span></span><br><span class="line"><span class="comment">// &#125;/*for循环使用let关键字也可以解决作用域的问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*函数变量：函数被调用之前和其他变量一样是静态的，被调用的时候是动态的</span></span><br><span class="line"><span class="comment">* 凡是能够使用变量的地方，都可以使用函数，意味着除了变量的普通用法外，</span></span><br><span class="line"><span class="comment">* 还可以做这些事</span></span><br><span class="line"><span class="comment">* · 通过创建一个指向函数的变量来给函数起一个别名</span></span><br><span class="line"><span class="comment">* · 将函数放入数组中（可能混合其他类型的数据）</span></span><br><span class="line"><span class="comment">* · 将函数当作对象的属性</span></span><br><span class="line"><span class="comment">* · 将函数传入到另一个函数中</span></span><br><span class="line"><span class="comment">* · 从一个函数中返回一个函数</span></span><br><span class="line"><span class="comment">* · 从一个把函数当作参数的函数中返回一个函数*/</span></span><br><span class="line"><span class="comment">//别名</span></span><br><span class="line"><span class="function">function <span class="title">addThreeSquareAddFiveTakeSquareRoot</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">sqrt</span>(Math.<span class="built_in">pow</span>(x+<span class="number">3</span>,<span class="number">2</span>)+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f3 = addThreeSquareAddFiveTakeSquareRoot;</span><br><span class="line"><span class="keyword">const</span> answer = (f3(<span class="number">5</span>)+f3(<span class="number">2</span>))/f3(<span class="number">7</span>);</span><br><span class="line">console.<span class="built_in">log</span>(answer);</span><br><span class="line"><span class="comment">//数组中的函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">cos</span> = Math.<span class="built_in">cos</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">sin</span> = Math.<span class="built_in">sin</span>;</span><br><span class="line"><span class="keyword">const</span> theta = Math.PI/<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> zoom = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> offset = [<span class="number">1</span>,<span class="number">-3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pipeline = [</span><br><span class="line">    function rotate(p)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: p.x * <span class="built_in">cos</span>(theta) - p.y * <span class="built_in">sin</span>(theta),</span><br><span class="line">            y: p.x * <span class="built_in">sin</span>(theta) + p.y * <span class="built_in">cos</span>(theta)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">function <span class="title">scale</span><span class="params">(p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x: p.x * zoom, y: p.y * zoom&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">function <span class="title">translate</span><span class="params">(p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x: p.x + offset[<span class="number">0</span>],y: p.y + offset[<span class="number">1</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> p = &#123;x: <span class="number">1</span>,y: <span class="number">1</span>&#125;;</span><br><span class="line">let p2 = p;</span><br><span class="line"><span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;pipeline.length;i++)&#123;</span><br><span class="line">    p2 = pipeline[i](p2);</span><br><span class="line">    console.<span class="built_in">log</span>(p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将函数传给函数</span></span><br><span class="line"><span class="comment">/*之前已经接触了很多将函数传给函数的例子。比如把函数传给setTimeout或forEach。这样做</span></span><br><span class="line"><span class="comment">* 的另一个原因是为了管理异步编程。实现异步执行的常见方法是将一个函数(通常叫回调函数)</span></span><br><span class="line"><span class="comment">* 传给另一个函数。该函数在闭包函数执行完成时被调用*/</span></span><br><span class="line"><span class="function">function <span class="title">sum</span><span class="params">(arr,f)</span> </span>&#123;</span><br><span class="line">    if(typeof f != 'function')f = x =&gt; x;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce((a,x) =&gt; a+=f(x),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span> + sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line">console.<span class="built_in">log</span>(sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],x =&gt; x*x));</span><br><span class="line">console.<span class="built_in">log</span>(sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],x =&gt; Math.<span class="built_in">pow</span>(x,<span class="number">3</span>)));</span><br><span class="line"><span class="comment">//在函数中返回函数(有点难理解)</span></span><br><span class="line"><span class="comment">// function sumOfSquares(arr) &#123;</span></span><br><span class="line"><span class="comment">//     return sum(arr,x =&gt; x*x);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function">function <span class="title">newSummer</span><span class="params">(f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr =&gt; sum(arr,f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sumOfSquares = newSummer(x =&gt; x*x);</span><br><span class="line"><span class="keyword">const</span> sumOfCubes = newSummer(x =&gt; Math.<span class="built_in">pow</span>(x,<span class="number">3</span>));</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>+sumOfSquares([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line">console.<span class="built_in">log</span>(sumOfCubes([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//14章 异步编程</span></span><br><span class="line"><span class="comment">/*JavaScript对异步编程的支持有三个不同的阶段：</span></span><br><span class="line"><span class="comment">回调(callback)阶段</span></span><br><span class="line"><span class="comment">* promise阶段</span></span><br><span class="line"><span class="comment">* 生成器(generator)阶段*/</span></span><br><span class="line"><span class="comment">/*如果知识简单的说生成器比任何出现在它之前的阶段都好，那么只要了解生成</span></span><br><span class="line"><span class="comment">* 器的工作原理跳过其他的就行了，但实际上没这么简单。生成器本身并不提供</span></span><br><span class="line"><span class="comment">* 任何对异步的支持：他们依赖于承诺或特定类型的回调来提供异步行为。同样</span></span><br><span class="line"><span class="comment">* 像承诺这样有用的东西，会依赖于回调（而回调本身又由于具有对象而变得更</span></span><br><span class="line"><span class="comment">* 有用）。除了用户输入外，异步编程技术的三个主要使用场景是：</span></span><br><span class="line"><span class="comment">* 网络请求（如Ajax请求）</span></span><br><span class="line"><span class="comment">* 文件系统操作（读/写文件等）</span></span><br><span class="line"><span class="comment">* 刻意的时间延迟功能（比如警告等）*/</span></span><br><span class="line"><span class="comment">/*类比：在一个人满为患且没有预定的餐厅里找一个空桌子。此时不需要排队等</span></span><br><span class="line"><span class="comment">* ，当有位子的时候餐厅会给打电话。这就类似回调：给餐厅的工作人员提供了</span></span><br><span class="line"><span class="comment">* 一些信息，允许他们在有位子的时候通知客户。所以餐厅可以做自己的事，客</span></span><br><span class="line"><span class="comment">* 户也可以做自己的事，没有人在等其他人。另一家餐厅也许会给客户一个传呼</span></span><br><span class="line"><span class="comment">* 机，在位子准备好的时候就会响。这更像是一个承诺：餐厅工作人员会给客户</span></span><br><span class="line"><span class="comment">* 一个承诺，承诺在有空桌子的时候通知客户。*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习记录面向对象编程-动态属性-原型-静态方法-继承-map-WeakMap-异常</title>
    <url>/2019/11/26/JavaScript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7-%E5%8E%9F%E5%9E%8B-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E7%BB%A7%E6%89%BF-map-WeakMap-%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>Js面向对象编程</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">面向对象编程</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">const</span> car2 = <span class="keyword">new</span> Car();</span><br><span class="line">console.<span class="built_in">log</span>(car1 instanceof Car);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor(make,model)&#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.userGears = [<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'R'</span>,<span class="string">'D'</span>];</span><br><span class="line">        <span class="keyword">this</span>.userGear = <span class="keyword">this</span>.userGears[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    shift(gear)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.userGears.indexOf(gear)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear: $&#123;gear&#125;`);</span><br><span class="line">        <span class="keyword">this</span>.userGear = gear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">"Tesla"</span>,<span class="string">"Model S"</span>);</span><br><span class="line">car1.shift(<span class="string">'D'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car1.make,car1.model,car1.userGear);</span><br><span class="line">动态属性</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    constructor(make,model)&#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>._userGears = [<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'R'</span>,<span class="string">'D'</span>];<span class="comment">//穷人访问限制 给私有属性加下划线前缀</span></span><br><span class="line">        <span class="keyword">this</span>._userGear = <span class="keyword">this</span>._userGears[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">get</span> <span class="title">userGear</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._userGear; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">set</span> <span class="title">userGear</span><span class="params">(value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._userGears.indexOf(value)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear: $&#123;value&#125;`);</span><br><span class="line">        <span class="keyword">this</span>._userGear = value;</span><br><span class="line">    &#125;</span><br><span class="line">    shift(gear)&#123;<span class="keyword">this</span>.userGear = gear;&#125;</span><br><span class="line">&#125;<span class="comment">/*并没有解决直接赋值问题*/</span></span><br><span class="line"><span class="comment">// WeakMap强制属性私有化</span></span><br><span class="line"><span class="keyword">const</span> Car = (function () &#123;</span><br><span class="line">    <span class="keyword">const</span> carProps = <span class="keyword">new</span> WeakMap();</span><br><span class="line"></span><br><span class="line">    class Car &#123;</span><br><span class="line">        constructor(make, model) &#123;</span><br><span class="line">            <span class="keyword">this</span>.make = make;</span><br><span class="line">            <span class="keyword">this</span>.model = model;</span><br><span class="line">            <span class="keyword">this</span>._userGears = [<span class="string">'P'</span>, <span class="string">'N'</span>, <span class="string">'R'</span>, <span class="string">'D'</span>];</span><br><span class="line">            carProps.<span class="built_in">set</span>(<span class="keyword">this</span>, &#123;userGear: <span class="keyword">this</span>._userGears[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">get</span> userGear() &#123;</span><br><span class="line">            <span class="keyword">return</span> carProps.<span class="built_in">get</span>(<span class="keyword">this</span>).userGear;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">set</span> userGear(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._userGears.indexOf(value) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(`Invalid gear:$&#123;value&#125;`);</span><br><span class="line">            carProps.<span class="built_in">get</span>(<span class="keyword">this</span>).userGear = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        shift(gear) &#123;</span><br><span class="line">            <span class="keyword">this</span>.userGear = gear;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Car;</span><br><span class="line">&#125;)();<span class="comment">/*这里使用即时调用函数将WeakMap隐藏再一个闭包内，从而阻止了外界的访问。这个WeakMap可以安全的存储任何不</span></span><br><span class="line"><span class="comment">像被Car类外部访问的属性*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原型</span></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">const</span> car2 = <span class="keyword">new</span> Car();</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === Car.prototype.shift);</span><br><span class="line">car1.shift(<span class="string">"D"</span>);</span><br><span class="line"><span class="comment">//car1.shift('d')报错</span></span><br><span class="line">console.<span class="built_in">log</span>(car1.userGear);</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === car2.shift);</span><br><span class="line"></span><br><span class="line">car1.shift = function (gear) &#123;</span><br><span class="line">    <span class="keyword">this</span>.userGear = gear.toUpperCase();</span><br><span class="line">&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === Car.prototype.shift);</span><br><span class="line">console.<span class="built_in">log</span>(car1.shift === car2.shift);</span><br><span class="line">car1.shift(<span class="string">'d'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car1.userGear);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*到目前为止，讨论的方法都是实例方法。它们只针对每个具体的实例才有用。还有一种静态方法，它不与实例绑定。在静态</span></span><br><span class="line"><span class="comment">方法中，this绑定的是类本身，但通常使用类名来代替this是公认的最佳实践。静态方法通常用来执行与类相关的任务，而非</span></span><br><span class="line"><span class="comment">跟具体的实例相关。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car1</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">getNextVin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Car1.nextVin++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(make, model) &#123;</span><br><span class="line">        <span class="keyword">this</span>.make = make;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">        <span class="keyword">this</span>.vin = Car1.getNextVin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">areSimilar</span><span class="params">(car1, car2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car1.make === car2.make &amp;&amp; car1.model === car2.model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">areSame</span><span class="params">(car1, car2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car1.vin === car2.vin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car1.nextVin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car3 = <span class="keyword">new</span> Car1(<span class="string">"Tesla"</span>, <span class="string">"S"</span>);</span><br><span class="line"><span class="keyword">const</span> car4 = <span class="keyword">new</span> Car1(<span class="string">"Mazda"</span>, <span class="string">"3"</span>);</span><br><span class="line"><span class="keyword">const</span> car5 = <span class="keyword">new</span> Car1(<span class="string">"Mazda"</span>, <span class="string">"3"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(car3.vin);</span><br><span class="line">console.<span class="built_in">log</span>(car4.vin);</span><br><span class="line">console.<span class="built_in">log</span>(car5.vin);</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSimilar(car3, car4));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSimilar(car4, car5));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSame(car4, car5));</span><br><span class="line">console.<span class="built_in">log</span>(Car1.areSame(car4, car4));</span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line"><span class="comment">/*在分析原型的时候，已经看到了继承的身影：当创建一个类的实例时，它继承了类原型中的所有的功能。如果一个方法没</span></span><br><span class="line"><span class="comment">有在对象原型中找到其定义，它会检查原型的原型。这样就建立了一个原型链。JavaScript会沿着原型链走下去，直到某个</span></span><br><span class="line"><span class="comment">原型满足了需求。如果找不到这样的原型，程序最终会报错。原型链的最大好处就是能够建立类的层次结构。前面已经讨论</span></span><br><span class="line"><span class="comment">了汽车如何归属与一种交通工具。原型链允许将功能置于最合适的继承层次上。例如，汽车可能有个方法deployAirbags，</span></span><br><span class="line"><span class="comment">可以将它当作一般的交通工具方法，但是，大家做过配备安全气囊的船吗？另一方面，几乎左右的交通工具都可以搭载乘客，</span></span><br><span class="line"><span class="comment">所以交通工具都可能有addPassenger的方法。下面实现这种场景*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.passengers = [];</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"Vehicle created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addPassenger(p) &#123;</span><br><span class="line">        <span class="keyword">this</span>.passengers.push(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car2</span> <span class="title">extends</span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();<span class="comment">//特殊函数 调用了父类的构造器，必须调用否则报错</span></span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"Car created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deployAirbags() &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"BWOOSH"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vehicle.prototype.sneaky = <span class="string">"not recommended!"</span>;</span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v.addPassenger(<span class="string">"Frank"</span>);</span><br><span class="line">v.addPassenger(<span class="string">"Judy"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(v.passengers);</span><br><span class="line"><span class="keyword">const</span> c  = <span class="keyword">new</span> Car2();</span><br><span class="line">c.addPassenger(<span class="string">"Alice"</span>);</span><br><span class="line">c.addPassenger(<span class="string">"Cameron"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(let p in c)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;p&#125;: $&#123;c[p]&#125;`+</span><br><span class="line">        (c.hasOwnProperty(p) ? '' : '(inherited)'));</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"\n"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(c.passengers);</span><br><span class="line"><span class="comment">//v.deployAirbags()报错</span></span><br><span class="line">c.deployAirbags();<span class="comment">/*注意到可以在c上调用deployAirbags,但是不能在v上调用。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">const u1 = &#123;name:'Cynthia'&#125;;</span><br><span class="line">const u2 = &#123;name:'Jackson'&#125;;</span><br><span class="line">const u3 = &#123;name:'James'&#125;;</span><br><span class="line"><span class="comment">// const userRoles = new Map();</span></span><br><span class="line"><span class="comment">// userRoles.set(u1,"User");</span></span><br><span class="line"><span class="comment">// userRoles.set(u2,"User");</span></span><br><span class="line"><span class="comment">// userRoles.set(u3,"Admin");</span></span><br><span class="line"><span class="comment">//set()链式赋值</span></span><br><span class="line"><span class="comment">//const userRoles = new Map();</span></span><br><span class="line"><span class="comment">// userRoles</span></span><br><span class="line"><span class="comment">//     .set(u1,"User")</span></span><br><span class="line"><span class="comment">//     .set(u2,"User")</span></span><br><span class="line"><span class="comment">//     .set(u3,"Admin");</span></span><br><span class="line"><span class="comment">//map的构函数赋值</span></span><br><span class="line"><span class="keyword">const</span> userRoles = <span class="keyword">new</span> Map([</span><br><span class="line">    [u1,'User'],</span><br><span class="line">    [u2,'User'],</span><br><span class="line">    [u3,'Admin']</span><br><span class="line">]);</span><br><span class="line"><span class="comment">/*如果key已经在map种，调用set()后key对应的value就会被替换</span></span><br><span class="line"><span class="comment">* size属性返回map的元素个数</span></span><br><span class="line"><span class="comment">* keys()方法可以拿到map中的所有键，values()可以拿到所有的值</span></span><br><span class="line"><span class="comment">* entries()可以以数组的方式获取键值对，数组的第一个元素为键，第二个为值。所有的这些方法返回一个可</span></span><br><span class="line"><span class="comment">* 以迭代的对象从而可以用for...of循环迭代*/</span></span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.keys())console.<span class="built_in">log</span>(u.name);</span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.values())console.<span class="built_in">log</span>(u);;</span><br><span class="line"><span class="keyword">for</span>(let u of userRoles.entries())console.<span class="built_in">log</span>(`$&#123;u[<span class="number">0</span>].name&#125;: $&#123;u[<span class="number">1</span>]&#125;`);</span><br><span class="line"><span class="comment">//通过解构让迭代更自然</span></span><br><span class="line"><span class="keyword">for</span>(let [u,r] of userRoles.entries())console.<span class="built_in">log</span>(`$&#123;u.name&#125;: $&#123;r&#125;`);</span><br><span class="line"><span class="comment">//如果需要一个数组，可以用展开运算符：</span></span><br><span class="line">console.<span class="built_in">log</span>([...userRoles.values()]);</span><br><span class="line"><span class="comment">//使用delete()方法可以删除map中的一个条目</span></span><br><span class="line">userRoles.<span class="keyword">delete</span>(u2);</span><br><span class="line">console.<span class="built_in">log</span>(userRoles.<span class="built_in">size</span>)</span><br><span class="line"><span class="comment">//如果想删除所有调用clear()方法</span></span><br><span class="line">userRoles.<span class="built_in">clear</span>();</span><br><span class="line">console.<span class="built_in">log</span>(userRoles.<span class="built_in">size</span>);</span><br><span class="line"><span class="comment">//Weak maps</span></span><br><span class="line"><span class="comment">/*本质和Map相同除了以下几点</span></span><br><span class="line"><span class="comment">* key必须时对象</span></span><br><span class="line"><span class="comment">* WeakMap中的key可以被垃圾回收</span></span><br><span class="line"><span class="comment">* WeakMap不能被迭代或者清空*/</span></span><br><span class="line"><span class="keyword">const</span> SecretHolder = (function () &#123;</span><br><span class="line">    <span class="keyword">const</span> secrets = <span class="keyword">new</span> WeakMap();</span><br><span class="line">    <span class="keyword">return</span> class &#123;</span><br><span class="line">        setSecret(secret)&#123;</span><br><span class="line">            secrets.<span class="built_in">set</span>(<span class="keyword">this</span>,secret);</span><br><span class="line">        &#125;</span><br><span class="line">        getSecret()&#123;</span><br><span class="line">            <span class="keyword">return</span> secrets.<span class="built_in">get</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">/*这里把WeakMap放在IIFE中，同时还放入了一个使用它的类。在IIFE外，有一个叫做SectetHolder的类，这个类的实例可</span></span><br><span class="line"><span class="comment">以存储secrets.secret的赋值和取值只能分别通过setSecret方法和getSecret方法完成*/</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> SecretHolder();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> SecretHolder();</span><br><span class="line">a.setSecret(<span class="string">"secret A"</span>);</span><br><span class="line">b.setSecret(<span class="string">"secret B"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(a.getSecret() + b.getSecret());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Error对象</span></span><br><span class="line"><span class="function">function <span class="title">validateEmail</span><span class="params">(email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> email.match(/@/)?</span><br><span class="line">        email:</span><br><span class="line">        <span class="keyword">new</span> Error(`invalid email: $&#123;email&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> email = <span class="string">"jane@doe.com"</span>;</span><br><span class="line"><span class="keyword">const</span> validatedEmail = validateEmail(email);</span><br><span class="line"><span class="keyword">if</span>(validatedEmail instanceof Error)&#123;</span><br><span class="line">    console.error(`Error: $&#123;validatedEmail.message&#125;`);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`Valid email: $&#123;validatedEmail&#125;`);</span><br><span class="line">&#125;<span class="comment">/*可以通过typeof运算符判断返回的是不是Error实例然后通过Error的message属性来获取错误信</span></span><br><span class="line"><span class="comment">息。虽然这样使用Error实例完全合法，也很有用，但实际上，它的大部分应用场景都在异常处理</span></span><br><span class="line"><span class="comment">中，这也是接下来要学的内容*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用try...catch处理异常</span></span><br><span class="line"><span class="comment">/*如果将前面的例子中的email设为null、数字、对象等任何非字符串值时都会出错，此时程序将</span></span><br><span class="line"><span class="comment">* 会非常不友好的崩溃。为了防范这种非预期错误，可以将用于验证邮箱的代码封装在try..catch</span></span><br><span class="line"><span class="comment">* 语句中*/</span></span><br><span class="line"><span class="keyword">const</span> email_ = null;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> validatedEmail = validateEmail(email_);</span><br><span class="line">    <span class="keyword">if</span>(validatedEmail instanceof Error)&#123;</span><br><span class="line">        console.error(`Error: $&#123;validatedEmail.message&#125;`);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        console.<span class="built_in">log</span>(`Valid email: $&#123;validatedEmail&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(`Error: $&#123;e.message&#125;`);</span><br><span class="line">&#125;<span class="comment">/*捕获异常后，程序就不会再崩溃了，而是打印了错误日志后继续执行。不过可能还会有别的问题：</span></span><br><span class="line"><span class="comment">如果这里需要输入一个合法的邮箱，而用户输入了无效的邮箱，那程序继续运行下去也没有意义了。</span></span><br><span class="line"><span class="comment">注意，一旦有错误产生，执行逻辑立即跳到catch中。所以validateEmail调用语句后的if语句就不</span></span><br><span class="line"><span class="comment">会执行。也可以再try块中写入任何期望的语句，最先产生错误的语句会使执行逻辑跳转到catch块</span></span><br><span class="line"><span class="comment">中。如果try块中的语句没有任何错误，catch块中的代码就不会被执行，程序会继续运行下去。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="comment">/*function  billPay(amount,payee,account) &#123;</span></span><br><span class="line"><span class="comment">    if(amount &gt; account.balance)</span></span><br><span class="line"><span class="comment">        throw new Error("insufficient funds");</span></span><br><span class="line"><span class="comment">    account.transfer(payee,amount);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常处理和调用栈</span></span><br><span class="line"><span class="function">function <span class="title">a_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log('a: calling b');</span><br><span class="line">    b_();</span><br><span class="line">    console.log('a: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">b_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"b: calling c"</span>);</span><br><span class="line">    c_();</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"b: done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">c_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"c: throwing error"</span>);</span><br><span class="line">    throw new Error('c error');</span><br><span class="line">    console.log('c: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">function <span class="title">d_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.log('d: calling c');</span><br><span class="line">    c_();</span><br><span class="line">    console.log('d: done');</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    a_();</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e.<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    d_();</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(e.<span class="built_in">stack</span>);</span><br><span class="line">&#125;<span class="comment">/*栈轨迹从最深层的函数开始，直到没有函数调用。所以出现异常应该从最上面开始解决*/</span></span><br><span class="line"><span class="comment">//try...catch...finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"this line is executed..."</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"whoops"</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"whis line is not..."</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"there was an error.."</span>);</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"...always executed"</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"perform cleanup here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Script学习记录 异步深入</title>
    <url>/2019/11/26/Script%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20%E5%BC%82%E6%AD%A5%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<p>想吐槽一下，这个部分有点恶心 太绕了。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"Before timeout: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line"><span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"After timeout: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"I happen after setTimeout"</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"Me too"</span>);</span><br><span class="line"><span class="comment">/*可以看到代码编写的顺序与实际执行的顺序之间没有必然联系。这里就是回调异步*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//setInterval函数每隔一段特定的时间运行回调函数，并且一直运行下去，直到调用</span></span><br><span class="line"><span class="comment">//clearInterval函数</span></span><br><span class="line"><span class="keyword">const</span> start = <span class="keyword">new</span> Date();</span><br><span class="line">let i_1 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> intervalId = setInterval(function () &#123;</span><br><span class="line">    let now = <span class="keyword">new</span> Date();</span><br><span class="line">    ++i_1;</span><br><span class="line">    <span class="keyword">if</span>(now.getMinutes() !== start.getMinutes() || i_1&gt;<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> clearInterval(intervalId);</span><br><span class="line">    console.<span class="built_in">log</span>(`$&#123;i_1&#125;: $&#123;now&#125;`);</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br><span class="line"><span class="comment">/*setInterval返回了一个ID,在后面可以用来取消这次调用。与之对应的clearInterval</span></span><br><span class="line"><span class="comment">* 在timeout之前停止本次调用也是使用了这种方式</span></span><br><span class="line"><span class="comment">* setTimeout、setInterval、clearInterval都定义在全局对象中（浏览器中是window,</span></span><br><span class="line"><span class="comment">* Node中是global）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//scope和异步执行</span></span><br><span class="line"><span class="comment">/*异步执行中容易让人疑惑或犯错的一点是：scope和闭包是如何影响异步执行的。每当</span></span><br><span class="line"><span class="comment">* 一个函数被执行时，都创建了一个闭包：所有在函数内部创建的变量(包括形参)只在</span></span><br><span class="line"><span class="comment">* 有被访问的是时候才存在*/</span></span><br><span class="line"><span class="function">function <span class="title">contdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"Countdown:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(let i=<span class="number">5</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">            console.<span class="built_in">log</span>(i===<span class="number">0</span>?<span class="string">"Go!"</span>:i);</span><br><span class="line">        &#125;,(<span class="number">5</span>-i)*<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contdown();</span><br><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="comment">/*创建一个带有函数的promise实例，它应该包含一个resolve(满足)和reject的回调。*/</span></span><br><span class="line"><span class="function">function <span class="title">countdown_</span><span class="params">(seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve,reject) &#123;</span><br><span class="line">        <span class="keyword">for</span>(let i=seconds;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">                <span class="keyword">if</span>(i===<span class="number">13</span>)<span class="keyword">return</span> reject(<span class="keyword">new</span> Error(<span class="string">"DEFINITELY NOT COUNTING THAT"</span>));</span><br><span class="line">                if(i&gt;0)console.log(i+'...');</span><br><span class="line">                <span class="keyword">else</span> resolve(console.<span class="built_in">log</span>(<span class="string">"Go"</span>));</span><br><span class="line">            &#125;,(seconds-i)*<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">countdown_(<span class="number">5</span>);</span><br><span class="line">使用promise</span><br><span class="line">countdown_(<span class="number">14</span>).then(</span><br><span class="line">    function () &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"countdown completed successfully"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    function (err) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">"countdown experienced an error: "</span>+err.message);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*从小于13的任何数字开始倒数都不会出错，从13或大于13的数字开始，则会在数到13的时候</span></span><br><span class="line"><span class="comment">* 会出错，但是控制台会一直打印log。调用reject并没能终止函数，他们只是修改了promise</span></span><br><span class="line"><span class="comment">* 的状态。显然countdown函数需要优化。通常，并不希望一个函数在被处理后还能继续运行</span></span><br><span class="line"><span class="comment">* (不管成功还是失败)，单数countdown却继续运行。控制台的log一点都不灵活，他们并不会</span></span><br><span class="line"><span class="comment">* 真的提供想要的控制权。</span></span><br><span class="line"><span class="comment">* promise提供了一个定义及其良好，并且可以安全地处理那些满足或者拒绝的异步任务的方式</span></span><br><span class="line"><span class="comment">* ，但是它却没有报告过程进度的能力。也就是说，promise只可能是满足或者拒绝，绝不会出</span></span><br><span class="line"><span class="comment">* 现“%50完成”。有的promise库中增加了一些很有用的功能，比如，可以报告过程,很可能</span></span><br><span class="line"><span class="comment">* JavaScript中的promise也会具备那些功能，不过现在，我们只能在没有这些功能的情况下</span></span><br><span class="line"><span class="comment">* 工作。如果想要这些功能，需要继续学习下面的内容*/</span></span><br><span class="line"><span class="comment">//事件</span></span><br><span class="line"><span class="comment">/*事件发射器可以广播事件，任意愿意监听这些事件的人都可以去做这件事。如何监听事件呢？</span></span><br><span class="line"><span class="comment">* 答案是回调。创建自己的事件系统其实很简单，即便如此，Node还是为我们提供了内建的支持</span></span><br><span class="line"><span class="comment">* 。如果使用浏览器，jQuery同样提供了一个事件机制（http://api.jquery.com/category/events）</span></span><br><span class="line"><span class="comment">* 。为了改进countdown，我们通常会Node的EvenEmitter。虽然也可以在像countdown这样的</span></span><br><span class="line"><span class="comment">* 函数中使用EventEmitter,不过实际上他的设计初衷时跟类一起使用。所以可以把countdown</span></span><br><span class="line"><span class="comment">* 函数放在Countdown类中。*/</span></span><br><span class="line">const EventEmitter = require('events').EventEmitter;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span> <span class="title">extends</span> <span class="title">EventEmitter</span>&#123;</span></span><br><span class="line">    constructor (seconds,superstitious)&#123;</span><br><span class="line">        super();</span><br><span class="line">        <span class="keyword">this</span>.seconds = seconds;</span><br><span class="line">        <span class="keyword">this</span>.superstitious = superstitious;</span><br><span class="line">    &#125;</span><br><span class="line">    go()&#123;</span><br><span class="line">        <span class="keyword">const</span> countdown = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve,reject) &#123;</span><br><span class="line">            <span class="keyword">for</span>(let i=countdown.seconds;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(function () &#123;</span><br><span class="line">                    <span class="keyword">if</span>(countdown.superstitious &amp;&amp; i===<span class="number">13</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> reject(<span class="keyword">new</span> Error(<span class="string">"DEFINITELY NOT COUNTING THAT"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    countdown.emit('tick',i);</span><br><span class="line">                    <span class="keyword">if</span>(i===<span class="number">0</span>)resolve();</span><br><span class="line">                &#125;,(countdown.seconds-i)*<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Countdown类继承了EventEmitter,这样Countdown就可以发射事件。Go方法是正式开始倒计时</span></span><br><span class="line"><span class="comment">* 并返回promise的地方。注意在go函数中，我们做的第一件事就是把this赋给countdown。这</span></span><br><span class="line"><span class="comment">* 是应为在回调中，不论倒计时是否迷信数字，都需要this的值来获取倒计时的长度。要记住</span></span><br><span class="line"><span class="comment">* this是一个特殊变量，它与回调中的this不是同一个东西。所以我们需要保存当前的this值，</span></span><br><span class="line"><span class="comment">* 从而在promise中使用它。任何想要监听tick事件（可以任意命名）的人都可以监听它。接下</span></span><br><span class="line"><span class="comment">* 来看看如何使用这经过改进后的全新countdown。*/</span></span><br><span class="line"><span class="keyword">const</span> c_1 = <span class="keyword">new</span> Countdown(<span class="number">13</span>);</span><br><span class="line">c_1.on('tick',function (i) &#123;</span><br><span class="line">    if(i&gt;0)console.log(i+'...');</span><br><span class="line">&#125;);</span><br><span class="line">c_1.go().then(function () &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"Go"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">catch</span>(function (err) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(err.message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode329矩阵中的最长递增路径</title>
    <url>/2019/11/26/leetcode329%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数矩阵，找出最长递增路径的长度。<br>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。（就是非常经典的滑雪题）</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums =</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 最长递增路径为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>]。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums =</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 最长递增路径是 [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>

<ul>
<li>来源：力扣（LeetCode）</li>
<li>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix</a></li>
</ul>
<blockquote>
<p>思路比较简单就是深搜+记忆化搜索</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;f;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y]!=<span class="number">-1</span>)<span class="keyword">return</span> f[x][y];<span class="comment">//记忆化</span></span><br><span class="line">        f[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = x+dx[i],b=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;n&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;m&amp;&amp;matrix[x][y]&gt;matrix[a][b])</span><br><span class="line">                f[x][y] = <span class="built_in">max</span>(f[x][y],dp(a,b,matrix)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>(),m=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,dp(i,j,matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包总结</title>
    <url>/2019/11/26/01%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第i件物品的体积是 vi，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>输入格式<br>第一行两个整数N，V，用空格隔开，分别表示物品数量和背包容积。<br>接下来有 N 行，每行两个整数 vi,wi用空格隔开，分别表示第 i 件物品的体积和价值。<br>输出格式<br>输出一个整数，表示最大价值。<br>数据范围</p>
</blockquote>
<p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入样例</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路：今天太晚了，明天补上。三种方法，依次进行优化<br>增补：F[i,j]表示从前i个物品中选出了总体积为j的物品放入背包，物品的最大价值和。<br>F[i,j]=max(F[i-1,j],F[i-1,j-vi]+wi)<br>初值F[0,0]=0,其余负无穷，目标：max{F[N][j]} 0&lt;=j&lt;=m<br>//最朴素的做法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[N+<span class="number">1</span>][V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=V;j++)&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[N][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>//使用滚动数组的做法<br>通过DP的状态转移方程，可以发现，每一阶段i的状态只与上一阶段i-1的状态有关。这种情况下，可以使用滚动数组的优化方法，降低空间开销。把阶段i的状态存储在第一位下标为i&amp;1的二维数组中。当i为奇数时，i&amp;1=1；当i为偶数时，i&amp;1=0;因此，DP的状态就相当于在F[0][]和F[1][]两个数组中交替转移，空间复杂度从O(nm)降低为O(m)。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">2</span>][V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j]=f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=V;j++)&#123;</span><br><span class="line">            f[i&amp;<span class="number">1</span>][j]=<span class="built_in">max</span>(f[i&amp;<span class="number">1</span>][j],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[N&amp;<span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>//线性空间做法<br>进一步分析上面代码，容易发现在每个阶段开始时，实际上执行了一次从F[i-1][]到F[i][]的拷贝操作。这提示我们可以进一步省略调F数组的第一维，只用一维数组，即当外层循环到第i个物品时，F[j]表示背包中放入总体积为j的物品的最大价值和。请注意下述代码使用了倒序循环。循环到j时：<br>1.F数组的后半部分F[jm]处于第i阶段，也就是已经考虑过放入第i个物品的情况。<br>2.前半部分F[0j-1]处于第i-1阶段，也就是没有第i个物品更新。<br>接下来j不断减小，意味着我们总是用第i-1阶段的状态向第i个阶段状态转移。<br>如果使用正序循环，假设F[j]被F[j-vi]+wi更新，接下来j增大到j+vi时，F[j+vi]又可能被F[j]+wi更新。此时，两个都处于第i个状态的状态之间发生了转移，相当于第i个物品被使用了两次。所以，必须使用倒序循环才符合0/1背包问题中每个物品是唯一的，只能放入背包一次。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,V;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;V);</span><br><span class="line">    <span class="keyword">int</span> f[V+<span class="number">1</span>],v[N+<span class="number">1</span>],w[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0xcf</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=V;j++)ans = <span class="built_in">max</span>(ans,f[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode322零钱兑换</title>
    <url>/2019/11/26/leetcode322%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>说明: 你可以认为每种硬币的数量是无限的。</li>
</ul>
<blockquote>
<p>思路：经典的dp问题，完全背包。得找个时间把背包九讲复习整理一遍。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;f(amount+<span class="number">1</span>,INT_MAX/<span class="number">2</span>);</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = c;i&lt;=amount;i++)&#123;</span><br><span class="line">                f[i] = <span class="built_in">min</span>(f[i],f[i-c]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[amount]==INT_MAX/<span class="number">2</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode357计算各个位数不同的数字个数</title>
    <url>/2019/11/26/leetcode357%E8%AE%A1%E7%AE%97%E5%90%84%E4%B8%AA%E4%BD%8D%E6%95%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10^n 。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: <span class="number">91</span></span><br><span class="line">解释: 答案应为除去 <span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span> 外，在 [<span class="number">0</span>,<span class="number">100</span>) 区间内的所有数字。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路：这题第一感觉就是找规律…可以结合一些组合数学的知识然后dp解决。可以这样考虑，n限制了我们需要考虑的数的位数，稍微思考一下就可以得出如下结论，对于一个n位数，第一位数有9种选择（0要排除），第二位数不能和第一位数相同故有9种选择，第三位数不能和前两位数相同故有8种选择..依此类推到最后一位数，算完后要加上n-1位各个位数不同的数字个数(第一位是0的情况)。举例：n=1时各个位数不同的数字有10个，n=2时由上述过程各个位数不同的数字有9*9+10=91个。实现代码如下：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans[<span class="number">10</span>];</span><br><span class="line">        ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">9</span>,k=<span class="number">1</span>;k&lt;i;k++)&#123;</span><br><span class="line">                temp = temp * j;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = temp * <span class="number">9</span> + ans[i<span class="number">-1</span>];            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>动态规划</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
